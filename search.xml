<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>缓存淘汰算法-LRU</title>
    <url>/2021/06/09/Algorithm/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU/</url>
    <content><![CDATA[<h1 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h1><p>维护一个单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul>
</li>
</ol>
<p><img src="/2021/06/09/Algorithm/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU/LRU-single-linkedlist.jpg"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>无论访问的数据是否在链表中已存在，都需要遍历链表确认一遍。时间复杂度为O(n)</p>
<ol>
<li>如果节点在链表中存在。将其从原来位置删除和再插入到链表头部的时间复杂度均为O(1)。</li>
<li>如果节点在链表中不存在。链表未满时，直接做链表的插入操作，时间复杂度O(1)。链表满时，先删除链表尾结点，时间复杂度O(1)。再做插入操作，时间复杂度也是O(1)。</li>
</ol>
<p>均摊时间复杂度为O(n)</p>
<p>使用了除链表本身外的length和capacity来表示当前有多少个节点和一共有多少个节点，空间复杂度应为为O(1)</p>
<h1 id="链表-散列表法"><a href="#链表-散列表法" class="headerlink" title="链表+散列表法"></a>链表+散列表法</h1><p>维护一个双向链表和一个哈希表。</p>
<p>双向链表用来维护数据，并实现LRU算法。Hash表用来降低时间复杂度。</p>
<ol>
<li>如果节点在链表中不存在，则在链表中新增节点，并计算key的哈希值，将其放到hashmap中，hash表中存放该节点的指针。</li>
<li>如果节点存在，则在链表中，将其从原来的位置删除，再插入到链表头部。</li>
<li>淘汰时，删除链表尾结点，在链表头部插入新元素。</li>
</ol>
<p><img src="/2021/06/09/Algorithm/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU/LRU-hash-doublelinklist.png"></p>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>查询时：</strong></p>
<p>如果数据量较小的话，理论上来说，如果n个数据平均散列到m个槽上，则每个槽上的链表长度为k=n/m。时间复杂度为O(k)。</p>
<p>如果数据量较大的话，均匀分布下，哈希表的查询复杂度为O(1)。链表平均分布的情况下，查询时间复杂度为O(k)。均摊后，时间复杂度为O(1)。</p>
<p><strong>插入和删除操作时：</strong></p>
<p>因为使用了哈希表，哈希表中存放了双向链表的节点地址，所以访问链表节点的时间复杂度由O(n)，降低到了O(1)。而双向链表的插入和删除操作的时间复杂度均为O(1)。所以均摊后，时间复杂度为O(1)</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://leetcode-cn.com/problems/lru-cache-lcci/">力扣 16.25. LRU 缓存</a><br><a href="https://time.geekbang.org/column/article/64858">GeekTime 数据结构与算法之美 - 20 | 散列表（下）</a><br><a href="https://time.geekbang.org/column/article/41013">GeekTime 数据结构与算法之美 - 6 | 链表（上）</a><br><a href="https://github.com/Owl0214/algorithm/tree/main/LRU">Demo传送门</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署GitLab</title>
    <url>/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2GitLab/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建Redis服务</li>
<li>搭建PostgreSQL服务</li>
<li>搭建Gitlab服务并配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3></li>
<li>postgres:13.2</li>
<li>redis:6.2.3</li>
<li>gitlab/gitlab-ce:13.11.4-ce.0</li>
</ul>
<p>镜像说明：因之前部署了sonarqube，使用了postgres，所以此处使用的镜像版本，与部署Sonar的相同，网上帖子中，普遍使用的gitlab、redis、postgresql均为samessrsbn的版本，我均选择了各组件的官方镜像。此处也可以复用sonar已经部署的postgres，而不用另外创建。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="官方部署方式"><a href="#官方部署方式" class="headerlink" title="官方部署方式"></a>官方部署方式</h3><p><a href="https://docs.gitlab.com/charts/">官方文档</a>推荐使用Helm安装部署，但会安装很多如Grafana、Prometheus等附加组件。</p>
<h3 id="自定义资源清单"><a href="#自定义资源清单" class="headerlink" title="自定义资源清单"></a>自定义资源清单</h3><p>只部署了postgres、redis和gitlab，其他组件，有需要时，可自定义清单文件进行配置。其中部署gitlab时，需要手动创建共享存储挂载卷目录<code>/usr/nfs/data/gitlab/data</code>、<code>/usr/nfs/data/gitlab/config</code>、<code>/usr/nfs/data/gitlab/log</code></p>
<p><a href="https://github.com/Owl0214/DevOps/tree/main/gitlab">gitlab资源清单</a></p>
<h3 id="配置LDAP"><a href="#配置LDAP" class="headerlink" title="配置LDAP"></a>配置LDAP</h3><p>修改配置文件gitlab.rb，容器内路径为/etc/gitlab，容器外为nfs对应目录。修改后，重启pod或在容器内执行<code>gitlab-ctl reconfigure</code>。此处提供两种配置方式，两种仅格式不同，第一种为<a href="https://docs.gitlab.com/13.11/ee/administration/auth/ldap/index.html">官方示例</a>格式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">gitlab_rails[&#x27;ldap_enabled&#x27;]</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">gitlab_rails[&#x27;prevent_ldap_sign_in&#x27;]</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">gitlab_rails[&#x27;ldap_servers&#x27;]</span> <span class="string">=</span> &#123;</span><br><span class="line"><span class="string">&#x27;main&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">  <span class="string">&#x27;label&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;LDAP&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;host&#x27;</span> <span class="string">=&gt;</span>  <span class="string">&#x27;10.0.38.82&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;port&#x27;</span> <span class="string">=&gt;</span> <span class="number">30423</span>,</span><br><span class="line">  <span class="string">&#x27;uid&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;encryption&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;plain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;verify_certificates&#x27;</span> <span class="string">=&gt;</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;bind_dn&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn=admin,dc=example,dc=org&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;password&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;verify_certificates&#x27;</span> <span class="string">=&gt;</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;tls_options&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">    <span class="string">&#x27;ca_file&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ssl_version&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ciphers&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cert&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;timeout&#x27;</span> <span class="string">=&gt;</span> <span class="number">10</span>,</span><br><span class="line">  <span class="string">&#x27;active_directory&#x27;</span> <span class="string">=&gt;</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;allow_username_or_email_login&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&#x27;block_auto_created_users&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&#x27;base&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;dc=example,dc=com&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;user_filter&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span> <span class="string">=&gt;</span> [<span class="string">&#x27;uid&#x27;</span>, <span class="string">&#x27;userid&#x27;</span>, <span class="string">&#x27;sAMAccountName&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;email&#x27;</span> <span class="string">=&gt;</span> [<span class="string">&#x27;mail&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;userPrincipalName&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;first_name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;givenName&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;last_name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;sn&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;lowercase_usernames&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="comment"># EE Only</span></span><br><span class="line">  <span class="string">&#x27;group_base&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;admin_group&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;external_groups&#x27;</span> <span class="string">=&gt;</span> [],</span><br><span class="line">  <span class="string">&#x27;sync_ssh_keys&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## LDAP Settings</span></span><br><span class="line"><span class="comment">##! Docs: https://docs.gitlab.com/omnibus/settings/ldap.html</span></span><br><span class="line"><span class="comment">##! **Be careful not to break the indentation in the ldap_servers block. It is</span></span><br><span class="line"><span class="comment">##!   in yaml format and the spaces must be retained. Using tabs will not work.**</span></span><br><span class="line"></span><br><span class="line"><span class="string">gitlab_rails[&#x27;ldap_enabled&#x27;]</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">gitlab_rails[&#x27;prevent_ldap_sign_in&#x27;]</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##! **remember to close this block with &#x27;EOS&#x27; below**</span></span><br><span class="line"><span class="string">gitlab_rails[&#x27;ldap_servers&#x27;]</span> <span class="string">=</span> <span class="string">YAML.load</span> <span class="string">&lt;&lt;-&#x27;EOS&#x27;</span></span><br><span class="line">  <span class="attr">main:</span> <span class="comment"># &#x27;main&#x27; is the GitLab &#x27;provider ID&#x27; of this LDAP server</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">&#x27;LDAP&#x27;</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">&#x27;10.0.38.82&#x27;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">30423</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">&#x27;cn&#x27;</span></span><br><span class="line">    <span class="attr">bind_dn:</span> <span class="string">&#x27;cn=admin,dc=example,dc=org&#x27;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    <span class="attr">encryption:</span> <span class="string">&#x27;plain&#x27;</span> <span class="comment"># &quot;start_tls&quot; or &quot;simple_tls&quot; or &quot;plain&quot;</span></span><br><span class="line">    <span class="attr">verify_certificates:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">smartcard_auth:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">active_directory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">allow_username_or_email_login:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">lowercase_usernames:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">block_auto_created_users:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">base:</span> <span class="string">&#x27;dc=example,dc=org&#x27;</span></span><br><span class="line">    <span class="attr">user_filter:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">## EE only</span></span><br><span class="line">    <span class="attr">group_base:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">admin_group:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">sync_ssh_keys:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">EOS</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>访问页面，认证窗口处，显示LDAP和Standard两种登录认证方式。</p>
<p><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2GitLab/login.png" alt="1"></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署Jenkins</title>
    <url>/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建Jenkins服务</li>
<li>配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3>jenkins/jenkins:lts-jdk11</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建NFS"><a href="#创建NFS" class="headerlink" title="创建NFS"></a>创建NFS</h3><h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/jenkins">jenkins资源清单</a></p>
<h3 id="启动Jenkins"><a href="#启动Jenkins" class="headerlink" title="启动Jenkins"></a>启动Jenkins</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/jenkins</span><br><span class="line">kubectl apply -f .</span><br></pre></td></tr></table></figure>

<h3 id="访问Web页面"><a href="#访问Web页面" class="headerlink" title="访问Web页面"></a>访问Web页面</h3><p>访问入口：http://[NodeIp]:30002/</p>
<p><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/first-visit.png"></p>
<p>初次访问时，需要使用initialAdminPassword中的字符串进行登录，由于配置了共享存储，可不用进入容器中查询，直接到相应的挂载目录下查找。</p>
<p><code>cat [共享存储路径]/secrets/initialAdminPassword</code></p>
<p>安装推荐插件，或自定义选择插件安装。<br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/install-tools.png"></p>
<h2 id="配置ldap登录"><a href="#配置ldap登录" class="headerlink" title="配置ldap登录"></a>配置ldap登录</h2><h3 id="创建LDAP组和用户"><a href="#创建LDAP组和用户" class="headerlink" title="创建LDAP组和用户"></a>创建LDAP组和用户</h3><ol>
<li>使用cn=admin,dc=example,dc=org登录LDAP</li>
<li>创建Posix Group，ldap</li>
<li>在Posix Group下创建User Account，admin</li>
</ol>
<h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><p>管理员登录jenkins后，进入<strong>Manage Jenkins</strong>，点击<strong>Security</strong>下的<strong>Configure Global Security</strong>。<br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/manage-jenkins.png"></p>
<p>在<strong>Configure Global Security</strong>页面下，配置安全域，选择LDAP方式。<br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/safe.png"></p>
<h4 id="配置详细信息"><a href="#配置详细信息" class="headerlink" title="配置详细信息"></a>配置详细信息</h4><ol>
<li>Server: LDAP服务器地址，使用ldap的Service名称+端口号<code>ldap://ldap-service:389</code>。因创建的ldap的Service类型是NodePort，也可以使用节点ip:port。</li>
<li>User search base: <code>dc=example,dc=org</code></li>
<li>User search filter: <code>uid=&#123;0&#125;</code></li>
<li>Group search base: <code>dc=example,dc=org</code></li>
<li>Manager DN: <code>cn=admin,dc=example,dc=org</code></li>
<li>Manager Password: <code>admin</code></li>
</ol>
<p><strong>配置完LDAP相关信息后，点击Test LDAP settings</strong><br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/test-success.png"></p>
<h4 id="配置LDAP后无法登录Jenkins问题"><a href="#配置LDAP后无法登录Jenkins问题" class="headerlink" title="配置LDAP后无法登录Jenkins问题"></a>配置LDAP后无法登录Jenkins问题</h4><p>由于配置不当导致Jenkins无法登录时，可以修改config.xml，去除ldap认证</p>
<ol>
<li>cd到NFS挂载的路径下，备份config.xml</li>
<li>在配置文件中找到</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">securityRealm</span> <span class="attr">class</span>=<span class="string">&quot;hudson.security.LDAPSecurityRealm&quot;</span> <span class="attr">plugin</span>=<span class="string">&quot;ldap@1.20&quot;</span>&gt;</span></span><br><span class="line">  ……</span><br><span class="line"><span class="tag">&lt;/<span class="name">securityRealm</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并将其修改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">securityRealm</span> <span class="attr">class</span>=<span class="string">&quot;hudson.security.HudsonPrivateSecurityRealm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">disableSignup</span>&gt;</span>false<span class="tag">&lt;/<span class="name">disableSignup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">enableCaptcha</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enableCaptcha</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">securityRealm</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署Nexus</title>
    <url>/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建Nexus服务</li>
<li>配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3>sonatype/nexus3:3.30.1</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/nexus">资源清单</a></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>因配置了Ingress，故需要在客户端host文件中，配置相应的域名解析如:win10下，修改C:\Windows\System32\drivers\etc\hosts文件，添加<code>xx.xx.xx.xx nexus.xxx.com</code>，该域名与Ingress中的配置相同。</p>
<p>浏览器访问<a href="http://nexus.xxx.com/">http://nexus.xxx.com</a> 即可访问nexu页面</p>
<h2 id="配置LDAP"><a href="#配置LDAP" class="headerlink" title="配置LDAP"></a>配置LDAP</h2><p><a href="https://help.sonatype.com/repomanager3/system-configuration/user-authentication/ldap">官网文档配置参照</a></p>
<h3 id="登录Nexus"><a href="#登录Nexus" class="headerlink" title="登录Nexus"></a>登录Nexus</h3><p>admin的初始化密码位于/nexus-data/admin.password，可在共享存储路径下查看admin.password文件。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/login.png"></p>
<p>初次登录页面时，会提示修改密码。然后开启匿名访问权限。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/AnonymousAccess.png"></p>
<h3 id="修改Configuration"><a href="#修改Configuration" class="headerlink" title="修改Configuration"></a>修改Configuration</h3><p>进入配置管理页面-&gt;Security-&gt;LDAP，点击Create connection</p>
<p><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/config.png"></p>
<h4 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h4><p>配置LDAP连接，点击Verify Connection。连接成功后提示Connection to LDAP server verified: ldap://xx.xx.xx.xx:xxxx</p>
<p><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/ldap-connection-config.png"></p>
<h4 id="用户、组过滤配置"><a href="#用户、组过滤配置" class="headerlink" title="用户、组过滤配置"></a>用户、组过滤配置</h4><p>配置完LDAP连接后，点击next配置用户和组。<br>在Configuration template的下拉框中，定义了配置的模板：</p>
<ul>
<li>Active Directory: </li>
<li>Generic Ldap Server:</li>
<li>Posix with Dynamic Groups:</li>
<li>Posix with Static Groups:</li>
</ul>
<p>配置用户组过滤条件后，点击Verify usermapping,会弹出用户列表。点击Verify Login，输入LDAP中的用户名密码，即可验证LDAP中的用户登录Nexus<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/user-group-config.png"></p>
<h2 id="角色配置"><a href="#角色配置" class="headerlink" title="角色配置"></a>角色配置</h2><p>Nexus创建的用户或LDAP的用户，需由管理员分配角色。</p>
<p>点击Security-&gt;Users，通过Source查看LDAP的用户列表。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/config-role.png"></p>
<p>双击用户列表中的用户，进入配置页面，选择相应的角色进行保存。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/user-role-bind.png"></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署SonarQube</title>
    <url>/2021/05/13/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2SonarQube/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建PostgreSQL数据库</li>
<li>搭建SonarQube</li>
<li>配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3></li>
<li>postgres 13.2</li>
<li>sonarqube 8.9.0-community</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建NFS-Provisioner"><a href="#创建NFS-Provisioner" class="headerlink" title="创建NFS Provisioner"></a>创建NFS Provisioner</h3><h3 id="创建PostgreSQL-和-SonarQube资源清单"><a href="#创建PostgreSQL-和-SonarQube资源清单" class="headerlink" title="创建PostgreSQL 和 SonarQube资源清单"></a>创建PostgreSQL 和 SonarQube资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/sonar">资源清单</a></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/sonar</span><br><span class="line">kubectl apply -f .</span><br></pre></td></tr></table></figure>

<h3 id="访问web页面"><a href="#访问web页面" class="headerlink" title="访问web页面"></a>访问web页面</h3><p>访问 http://[nodeIp]:30003</p>
<p>默认用户名: admin</p>
<p>默认密码: admin</p>
<p>首次登录后会要求修改密码</p>
<h2 id="配置ldap"><a href="#配置ldap" class="headerlink" title="配置ldap"></a>配置ldap</h2><p>在挂载卷路径下的conf文件夹中，新建或修改SonarQube的配置文件sonar.properties</p>
<p>根据<a href="https://docs.sonarqube.org/latest/instance-administration/delegated-auth">官方示例及相关配置项说明</a>将其修改为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># General Configuration</span></span><br><span class="line"><span class="meta">sonar.security.realm</span>=<span class="string">LDAP</span></span><br><span class="line"><span class="comment"># 这里使用了svc的名称，可以换成ip</span></span><br><span class="line"><span class="meta">ldap.url</span>=<span class="string">ldap://ldap-service:389</span></span><br><span class="line"><span class="comment"># 管理员的账号密码</span></span><br><span class="line"><span class="meta">ldap.bindDn</span>=<span class="string">cn=admin,dc=example,dc=org</span></span><br><span class="line"><span class="meta">ldap.bindPassword</span>=<span class="string">admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># User Configuration</span></span><br><span class="line"><span class="comment"># 用户的搜索路径，LDAP中用户的根节点</span></span><br><span class="line"><span class="meta">ldap.user.baseDn</span>=<span class="string">cn=ldap,dc=example,dc=org</span></span><br><span class="line"><span class="comment"># 制定搜索规则</span></span><br><span class="line"><span class="comment">#ldap.user.request=(&amp;(objectClass=inetOrgPerson)(uid=$&#123;login&#125;))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Group Configuration</span></span><br><span class="line"><span class="comment"># 用户组的搜索路径，LDAP中组的根节点</span></span><br><span class="line"><span class="meta">ldap.group.baseDn</span>=<span class="string">dc=example,dc=org</span></span><br><span class="line"><span class="comment"># 制定搜索规则</span></span><br><span class="line"><span class="comment">#ldap.group.request=(&amp;(objectClass=posixGroup)(gid=&#123;dn&#125;))</span></span><br></pre></td></tr></table></figure>

<p>修改后，使用<code>kubectl delete pod </code>删除sonarqube的Pod，重启sonarqube服务。使用ldap中的用户和密码测试登录是否成功。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Sonar</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署ldap</title>
    <url>/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2ldap/</url>
    <content><![CDATA[<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3></li>
<li>osixia/openldap stable</li>
<li>osixia/phpldapadmin stable</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建NFS共享目录"><a href="#创建NFS共享目录" class="headerlink" title="创建NFS共享目录"></a>创建NFS共享目录</h3><ol>
<li>创建NFS服务</li>
<li>依次创建目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/nfs/data/ldapdata</span><br><span class="line">mkdir /usr/nfs/data/ldapdata/db</span><br><span class="line">mkdir /usr/nfs/data/ldapdata/config</span><br><span class="line">mkdir /usr/nfs/data/ldapdata/certs</span><br></pre></td></tr></table></figure>

<h3 id="创建ldap资源清单"><a href="#创建ldap资源清单" class="headerlink" title="创建ldap资源清单"></a>创建ldap资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/ldap">ldap资源清单</a></p>
<h3 id="启动ldap和web管理页面"><a href="#启动ldap和web管理页面" class="headerlink" title="启动ldap和web管理页面"></a>启动ldap和web管理页面</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply ldap-deployment.yaml</span><br><span class="line">kubectl apply ldap-service.yaml</span><br><span class="line">kubectl apply phpldapadmin-deployment.yaml</span><br><span class="line">kubectl apply phpldapadmin-service.yaml</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2ldap/ldap-svc.png"></p>
<h3 id="访问Web页面"><a href="#访问Web页面" class="headerlink" title="访问Web页面"></a>访问Web页面</h3><p>访问http://[NodeIp]:30080/</p>
<p>默认用户名：cn=admin,dc=example,dc=org</p>
<p>默认密码：admin</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>ldap</tag>
      </tags>
  </entry>
  <entry>
    <title>cgroup</title>
    <url>/2021/08/21/Kubernetes/Docker/cgroup/</url>
    <content><![CDATA[<h1 id="Linux-cgroup"><a href="#Linux-cgroup" class="headerlink" title="Linux cgroup"></a>Linux cgroup</h1><p>cgroups(Control Groups)通过不同的子系统限制了不同的系统资源，每种子系统限制一种资源。每个子系统限制资源的方式都是类似的，就是把相关的一组进程分配到一个控制组中，然后通过树结构(hierarchy)进行管理。每个控制组设有自己的资源控制参数。</p>
<p>默认情况下，系统中，所有进程位于同一个cgroup，就是根，这个cgroup享有所有的系统资源。</p>
<p>通过cgroup文件系统可以建立一个新的cgroup，可以为其分配进程、资源等。</p>
<p>通过<code>mount</code>查看系统中已经挂载的cgroup。cgroup的根目录是以tmpfs的性质进行挂载的，<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/cgroup-mounttype.png"></p>
<p>通过cgroup可以将定额的系统资源（如CPU、内存等）分配给特定的一组进程。cgroup的主要功能包括：</p>
<ul>
<li>Resource limitation：资源限制，比如限制内存使用上限</li>
<li>Prioritization：优先级分配，通过分配CPU时间片数量及硬盘IO带宽大小，来控制进程运行的优先级</li>
<li>Accounting：资源统计，比如CPU使用时长、内存用量等。</li>
<li>Control：进程控制，比如挂起进程、恢复执行进程</li>
</ul>
<h2 id="cgroup子系统"><a href="#cgroup子系统" class="headerlink" title="cgroup子系统"></a>cgroup子系统</h2><p>cgroup本身是分层级的，一个根层下面像一棵树一样可以分很多层。每一层的cgroup文件系统目录下都有改成对应的资源配置文件。这些可以配置的文件都是cgroup子系统。</p>
<p>通过<code>lssubsys -m</code>，可以查看cgroup的子系统。在<code>/sys/fs/cgroup</code>下有cgroup的子目录，这些子目录均为cgroup的子系统。<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/cgroup-subsystem.png"></p>
<p>cgroup包含的子系统有：</p>
<ul>
<li>cpu：用于控制cgroup中所有进程可以使用的CPU时间片。主要限制进程的cpu使用率</li>
<li>cpuacct：可以生成cgroups中的进程的cpu使用报告</li>
<li>cpuset：对于多核cpu，可以为cgroups中的进程分配单独的cpu节点或者内存节点</li>
<li>memory：可以限制进程的memory使用量</li>
<li>blkio：可以限制进程的块设备io</li>
<li>devices：可以控制进程能够访问某些设备。通过提供device whilelist实现的，devices子系统通过在内核对设备访问的时候加入额外的检查实现。devices子系统本身只需要管理好设备访问列表。</li>
<li>net_cls：可以标记cgroups中进程的网络数据包，然后可以使用tc模块(traffic control)对数据包进行控制，限制网络带宽</li>
<li>net_prio：用来设计网络流量的优先级，对每个网络接口指定优先级</li>
<li>freezer：可以挂起或者恢复cgroups中的进程。freezer.state可能读出的值有3种，分贝是FROZEN（已挂起）、THAWED（正常运行、已恢复）、FREEZING（该值代表cgroup中有些进程现在不能被frozen，当这些进程从该cgroup消失时，FREEZING会变成FROZEN）</li>
<li>ns：可以使不同cgroups下面的进程使用不同的namespaces。ns子系统没有自己的控制文件，而且没有属于自己的状态信息。ns子系统实际上是提供了一种同命名空间的进程聚类的机制。具有相同命名空间的进程会在相同的cgroup分组中。</li>
<li>hugetlb：主要针对于HugeTLB系统（大页文件系统）进行限制</li>
<li>perf_event：对cgroup中的进程组进行性能监控</li>
<li>pids：限制在cgroup中创建的进程数量</li>
<li>rdma：限制cgroup中使用的rdma(Remot Direct Memory Access)</li>
</ul>
<h3 id="CPU子系统"><a href="#CPU子系统" class="headerlink" title="CPU子系统"></a>CPU子系统</h3><p>用于控制cgroup中所有进程可以使用的CPU时间片，cpu子系统下的cgroup目录中，存在一个cpu.shares的文件，对其写入整数值，可以控制该cgroup获得的时间片。</p>
<p>例如，在两个相同层级的cgroup中，都将cpu.shares设置为1，那么这两个cgroup将会有相同的CPU时间。如果将其中一个cgroup中的cpu.shares设置为2，那么该cgroup中可使用CPU时间是另一个cgroup中可使用CPU时间的两倍。</p>
<p>CPU子系统通过Linux CFS调度器(Completely Fair Scheduler)实现的，CPU子系统调度CPU访问控制有两种模式：CFS(Completely Fair Scheduler)和RTS(Real-Time Scheduler)，RTS的方式只有在进程中采用了RTS调度算法时才生效。</p>
<h3 id="cpuacct子系统"><a href="#cpuacct子系统" class="headerlink" title="cpuacct子系统"></a>cpuacct子系统</h3><p>cpuacct子系统自动生成cgroup中任务所使用的CPU报告。</p>
<ul>
<li>cpuacct.usage：该group及其子group的CPU总使用时间(ns)</li>
<li>cpuacct.stat：该group及其子group的CPU的用户态和内核态的分别使用时间(ns)</li>
<li>cpuacct.usage_percpu：该group及其子group的CPU分别使用时间(ns)</li>
</ul>
<h3 id="cpuset子系统"><a href="#cpuset子系统" class="headerlink" title="cpuset子系统"></a>cpuset子系统</h3><p>为cgroup中的任务分配独立的CPU（多核系统中）和内存节点。</p>
<ul>
<li>cpuset.cpus：绑定该group的CPU节点，如绑定该进程可以使用0、1、2、6、8这5个CPU，写入文件数据格式是”0-2,6,8”</li>
</ul>
<h3 id="memory子系统"><a href="#memory子系统" class="headerlink" title="memory子系统"></a>memory子系统</h3><p>可以设定cgroup中任务使用的内存限制，并自动生成由哪些任务使用的内存资源报告。memory子系统是通过Linux的resource counter机制实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> usage; <span class="comment">//记录资源的当前使用量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> max_usage; <span class="comment">//使用过的最大资源量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> limit; <span class="comment">//资源最大限制，分配超过此限制的资源将会导致失败</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> soft_limit; <span class="comment">//资源软限制，可以超过这个值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> failcnt; <span class="comment">//资源分配失败的次数</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">//自旋锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> *<span class="title">parent</span>;</span> <span class="comment">//形成资源统计组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>/sys/fs/cgroup/memory</code>下，创建文件夹<code>mkdir test</code>，即创建了一个子cgroup，子cgroup中的文件包含如下：<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/cgroup-memory-newtask.png"></p>
<ul>
<li>cgroup.event_control：用于eventfd的接口</li>
<li>memory.usage_in_bytes：显示当前已用的内存</li>
<li>memory.limit_in_bytes：设置/显示当前限制的内存额度</li>
<li>memory.failcnt：显示内存使用量达到限制值的次数</li>
<li>memory.max_usage_in_bytes：历史内存最大使用量</li>
<li>memory.soft_limit_in_bytes：设置/显示当前限制的内存软额度</li>
<li>memory.stat：显示当前cgroup的内存使用情况</li>
<li>memory.use_hierarchy：设置/显示是否将子cgroup的内存使用情况统计到当前cgroup里面</li>
<li>memory.force_empty：触发系统立即尽可能的回收当前cgroup中可以回收的内存</li>
<li>memory.pressure_level：设置内存压力的通知事件，配合cgroup.event_control一起使用</li>
<li>memory.swappiness：设置和显示当前的swappiness</li>
<li>memory.move_charge_at_immigrate：设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去</li>
<li>memory.oom_control：设置/显示oom controls相关的配置</li>
<li>memory.numa_stat：显示numa相关的内存</li>
</ul>
<h4 id="设置内存限制"><a href="#设置内存限制" class="headerlink" title="设置内存限制"></a>设置内存限制</h4><p>操作cgroup主要有以下3步：</p>
<ol>
<li>创建cgroup</li>
<li>设置cgroup参数</li>
<li>将进程PID写入cgroup的task</li>
</ol>
<p>例如设置内存限制步骤如下：</p>
<ol>
<li>创建新的cgroup<blockquote>
<p>cd /sys/fs/cgroup/memory<br>mkdir test<br>cd test</p>
</blockquote>
</li>
<li>设置memory.limit_in_bytes和memory.memsw.limit_in_bytes<br>memory.limit_in_bytes用于限制memeory的大小，memory.memsw.limit_in_bytes用于限制memeory+swap的大小。memory.memsw.limit_in_bytes的值应大于等于memory.limit_in_bytes<blockquote>
<p>cat memory.limit_in_bytes</p>
</blockquote>
</li>
</ol>
<p>9223372036854771712</p>
<blockquote>
<p>echo 100M &gt; memory.limit_in_bytes<br>cat memory.limit_in_bytes</p>
</blockquote>
<p>104857600</p>
<ol start="3">
<li>将bash设置到tasks中，并创建一个200M的文件<blockquote>
<p>echo $$&gt;tasks<br>dd if=/dev/zero of=/home/myfile bs=200M count=1</p>
</blockquote>
</li>
</ol>
<p>Killed</p>
<h3 id="blkio子系统"><a href="#blkio子系统" class="headerlink" title="blkio子系统"></a>blkio子系统</h3><p>为块设备设定输入/输出限制，比如物理设备(磁盘、固态硬盘、USB等)。</p>
<p>该子系统提供了两种控制I/O的方式：</p>
<ol>
<li>基于权重，每个group都可以设置一个数值，根据数值不同，系统分配响应的I/O。以下两个值同一个group中只能存在一个。<ul>
<li>blkio.weight：一个100~1000的数值，全局的权重</li>
<li>blkio.weight_device：一个100~1000的数值，指定设备的I/O的权重。会覆盖全局的权重值</li>
</ul>
</li>
<li>基于速度，每个group都有一个最大的速度，该group的进程I/O不能大于这个速度<ul>
<li>blkio.throttl.read_bps_device：指定该设备上的最大读速度(bytes/s)</li>
<li>blkio.throttle.read_iops_device：指定该设备上的最大读I/O (I/O read/s);</li>
<li>blkio.throttle.write_bps_device：指定该设备上最大写速度(bytes/s)</li>
<li>blkio.throttle.write_iops_device：指定该设备上的最大写IO(I/O read/s)</li>
<li>blkio.throttle.io_serviced：记录设备I/O操作总数</li>
<li>blkio.throttle.io_service_bytes：记录设备读取总数</li>
</ul>
</li>
</ol>
<p>其他参数：</p>
<ul>
<li>blkio.reset_stats：对当前文件写入一个整数可重置当前所有统计数据</li>
<li>blkio.time：指定设备的cgroup控制的I/O访问时间(ms)</li>
<li>blkio.sectors：指定设备的扇区操作数</li>
<li>blkio.io_service_time：指定设备的I/O工作时间(ns)</li>
<li>blkio.io_wait_time：cgroup等待I/O的时间</li>
<li>blkio.io_merged：被合并的I/O请求</li>
<li>blkio.io_queued：被cgroup放到队列的I/O请求</li>
</ul>
<h2 id="hierarchy"><a href="#hierarchy" class="headerlink" title="hierarchy"></a>hierarchy</h2><p>一个hierarchy是一组排列在树中的cgroups，树中的每个节点都是一个进程组，系统中的每一个任务都在其中的一个cgroup中，每棵树会关联到多个subsystem。系统中可以有多棵cgroup树。</p>
<p>通过<code>systemd-cgls</code>可已查看Linux cgroup层次结构树。可以显示指定控制组的所有成员进程及其子组和成员。例如：</p>
<blockquote>
<p>systemd-cgls / kubepods</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/cgroup/systemd-cgls.png"></p>
<p>系统阶段，systemd会将它在内核中找到的所有hierarchies挂载到<code>/sys/fs/cgroup</code>下的各个目录。除了<code>/sys/fs/cgroup/systemd</code>目录，其他目录都是对应的子系统。<code>/sys/fs/cgroup/systemd</code>是systemd维护自己使用的，不允许其他程序移动这个目录的内容。</p>
<p>通过将cgroup hierarchy系统绑定到systemd单元树上，systemd可以将资源管理的设置从进程级别移动带应用程序级别。因此，可以使用systemctl指令或者修改systemd单元的配置文件来管理单元相关的资源。</p>
<p>默认情况下，systemd会自动创建slice、scope和service三个层次结构：</p>
<ul>
<li>service：systemd基于单元配置文件启动的一个进程或一组进程。服务封装了指定的进程，以便它们可以作为一个集合启动和停止。服务以<code>name.service</code>的形式被命名。</li>
<li>scope：一组外部创建的进程。Scopes封装了由任意进程通过fork()函数启动和停止的进程，然后在运行时，由systemd注册这些进行。例如，用户会话、容器和虚拟机被视为作用域。作用域以<code>name.scope</code>的形式被命名。</li>
<li>slice：一组分层组织的单元。Slices不包含进程，他们组织了一个层级结构，其中放置了scope和service。实际的进程都包含在scope和service中。在这个层次树中，切片单元的每个名称都对应于层次结构中某个位置的路径。<code>-</code>字符用作路径组件的分隔符。切片以<code>parent-name.slice</code>的形式被命名。slice是parent的子切片。一个根切片表示为<code>-.slice</code></li>
</ul>
<p>服务、范围和切片单元直接映射到cgroup树中的对象。当这些单元被激活时，它们会直接映射到根据单元名称构建的 cgroup路径。例如，ex.service属于test-waldo.slice，会直接映射到<code>cgroup test.slice/test-waldo.slice/ex.service/</code>中。</p>
<h3 id="Subsystem、Hierarchies、Control-Groups、Task的关系"><a href="#Subsystem、Hierarchies、Control-Groups、Task的关系" class="headerlink" title="Subsystem、Hierarchies、Control Groups、Task的关系"></a>Subsystem、Hierarchies、Control Groups、Task的关系</h3><ol>
<li><p>一个hierarchy可以附加一个或者多个subsystem（同时参照规则2）。例如cpu子系统和memory子系统（或任意数量的子系统）可以附加到单个层次结构。<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/RMG-rule1.png"></p>
</li>
<li><p>任何single subsystem（例如cpu）都不能附加到多个hierarchy上。如果第二个hierarchy没有其他的subsystem，那么就可以依附，即可以存在两个都仅有cpu依附的hierarchy；如果第二个hierarchy上依附了其他的subsystem，那么就不能依附。如图，图中的编号表示子系统所附的时间序列，因为 Hierarchy B依附了其他系统，所以cpu子系统就不能依附了。<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/RMG-rule2.png"></p>
</li>
<li><p>每次在系统上创建新的hierarchy时，系统上所有task（进程）最初都是该层次结构的默认cgroup的成员，该cgroup称为<code>root cgroup</code>，在这个hierarchy中创建的所有<code>cgroup</code>都是这个<code>root cgroup</code>的子节点。对于创建的任何一个hierarchy，系统上每个task都可以是该层次结构中的一个cgroup的成员。</p>
<p> 一个task可以在多个cgroup中，只要这个task所在的每个cgroup在不同的hierarchy中。如果一个task成为同一个hierarchy中第二个cgroup的成员，那么他就会从该hierarchy中的第一个cgroup中删除。</p>
<p> 任何时候，同一个hierarchy的不同cgroup中，不会存在同一个task。</p>
<p> 如图，如果cpu和内存子系统连接到名为cpu_mem_cg的hierarchy中，而net_cls子系统连接到名为net的hierarchy中，那么httpd进程可以是cpu_mem_cg中任何一个cgroup的成员，也可以是net中的任何一个cgroup的成员，但其不能同时存在于cpu_mem_cg中的两个cgroup中。</p>
<p> 因为当创建第一个hierarchy时，系统上的每个task都至少是一个cgroup(root cgroup)的成员，所以，当使用cgroups时，每个task总是至少在一个cgroup中。<br> <img src="/2021/08/21/Kubernetes/Docker/cgroup/RMG-rule3.png"></p>
</li>
<li><p> 一个进程(task)fork出子进程时，子进程会自动继承父进程的cgroup成员。也可以将子task移动到不同的cgroup中。当fork完成，父子进程就完全独立了。</p>
<h2 id="cgroup1和cgroup2"><a href="#cgroup1和cgroup2" class="headerlink" title="cgroup1和cgroup2"></a>cgroup1和cgroup2</h2><p>当前kernel中允许cgroup v1版本和v2版本共存。<br>Cgroup v2将多hierarchy的方式变成了unified hierarchy，并将所有的controller挂载到一个unified hierarchy。</p>
</li>
</ol>
<p>主要改进：</p>
<ul>
<li>Cgroups v2 中所有的controller都会被挂载到一个unified hierarchy下，不在存在像v1中允许不同的controller挂载到不同的hierarchy的情况</li>
<li>Process只能绑定到cgroup的根(<code>/</code>)目录和cgroup目录树中的叶子节点</li>
<li>通过cgroup.controllers和cgroup.subtree_control指定哪些controller可以被使用</li>
<li>v1版本中的task文件和cpuset controller中的cgroup.clone_children文件被移除</li>
<li>当cgroup为空时的通知机制得到改进，通过cgroup.events文件通知</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://0pointer.de/blog/projects/cgroups-vs-cgroups.html">cgroups</a></li>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/resource_management_guide/index">Red Hat Enterprise Linux 7 的系统资源</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">Control Group v2</a></li>
<li><a href="https://blog.51cto.com/u_15127564/2666789">浅谈Cgroups v2</a></li>
<li><a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/">Docker 背后的内核知识——cgroups 资源限制</a></li>
<li><a href="https://www.lijiaocn.com/%E6%8A%80%E5%B7%A7/2019/01/28/linux-tool-cgroup-detail.html">Linux的cgroup功能（二）：资源限制cgroup v1和cgroup v2的详细介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Namespace</title>
    <url>/2021/08/21/Kubernetes/Docker/namespace/</url>
    <content><![CDATA[<h1 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h1><p>Linux Namespace是一种隔离机制，它将全局系统资源包装起来，使得PID、IPC、Network、Mount、UTS、User、CGroup不再是全局性的，而是属于特定的Namespace。每个Namespace下的资源对于其他Namespace都是不可见的。</p>
<p>一个进程可以属于多个Namespace。</p>
<h2 id="Namespace种类"><a href="#Namespace种类" class="headerlink" title="Namespace种类"></a>Namespace种类</h2><table>
<thead>
<tr>
<th>namespace 名称</th>
<th>系统调用参数</th>
<th>含义</th>
<th>kernel版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>隔离一组进程看到的文件系统的挂载点，不同的命名空间可以具有不同的文件系统结构</td>
<td>2.4.19</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>隔离进程编号，PID 命名空间的主要好处之一是容器可以在主机之间迁移，同时为容器内的进程保留相同的进程 ID。PID 命名空间还允许每个容器拥有自己的 init (PID 1)，即“所有进程的祖先”，管理各种系统初始化任务并在它们终止时回收孤立的子进程。</td>
<td>2.6.14</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>隔离网络设备，堆栈，端口等</td>
<td>2.6.29</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>隔离进程间通信系统 IPC, POSIX 消息队列</td>
<td>2.6.19</td>
</tr>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>隔离节点名和域名</td>
<td>2.6.19</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>隔离用户和组ID</td>
<td>3.8</td>
</tr>
<tr>
<td>Cgroup</td>
<td>CLONE_NEWCGROUP</td>
<td>隔离Cgroup 根目录，可以防止信息泄露而导致cgroup目录路径外部进程可见；隔离后，Cgroup路径名是独立的，容器迁移时，防止cgroup路径名与目标系统上的路径名发生冲突;将cgroup文件系统完全隔离开，可以防止容器进程无法访问主机的cgroup目录</td>
<td>4.6</td>
</tr>
</tbody></table>
<p>每种namespace各有自己管理的部分，<strong>对于现在 Linux 上的任意进程而言，它一定是<code>每种 namespace 的一个实例</code></strong> (<strong>就是每个进程都得归属于某个ns，ns中可以只有一个进程，也可以由多个进程共有</strong>)</p>
<p>隔离cgroup说明：假设一个场景，有一个cgroup目录<code>/cg/1</code>，它归USER ID 9000所有，有一个进程X也归USER ID 9000所有，该进程的命名空间位于cgroup目录<code>/cg/1/2</code>。在没有cgroup命名空间的情况下，因为cgroup目录<code>/cg/1</code>由UID 9000拥有（可写）并且进程X也由UID 9000所有，进程X则既能修改<code>/cg/1</code>的文件，也能修改<code>/cg/1/2</code>的文件。通过cgroup namespace，可以防止进程X修改<code>/cg/1</code>的中的文件，因为它看不到该目录。这样可以防止进程X逃逸其ancestor cgroup的限制。</p>
<p><strong>Linux 提供了以下主要的系统调用</strong>用于管理namespace：</p>
<ul>
<li>clone()：如果是纯粹只使用clone()，则会创建一个新进程；但如果我们传递一个或多个 CLONE_NEW* 标志参数给clone()，则会根据每个标志创建对应的新namespace 并且将子进程添加为其成员，达到隔离效果。</li>
<li>setns()：允许进程加入一个已存在的 namespace 中。</li>
<li>unshare()：允许进程（或线程）取消其执行上下文中，与其他进程（或线程）共享部分的关联，通俗点来说，也就是可以利用此系统调用来让当前的进程（或线程）移动至一个新的namespace中。</li>
</ul>
<h3 id="隔离IPC"><a href="#隔离IPC" class="headerlink" title="隔离IPC"></a>隔离IPC</h3><p>IPC 全称 Inter-Process Communication，是进程间通信的一种方式，IPC有管道、共享内存、信号量、消息队列、信号、套接字。</p>
<ol>
<li>查看主机信号量<br><img src="/2021/08/21/Kubernetes/Docker/namespace/ipcs1.png"></li>
<li>主机上创建信号量</li>
</ol>
<blockquote>
<p>ipcmk -S 10</p>
</blockquote>
<blockquote>
<p>ipcs</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ipcs_host.png"></p>
<ol>
<li>创建一个新的IPC Namespace，然后查看ns中的信号量<blockquote>
<p>unshare –ipc</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ipcs_ns.png"></p>
<h3 id="隔离UTS"><a href="#隔离UTS" class="headerlink" title="隔离UTS"></a>隔离UTS</h3><p>UTS(Unix Timesharing System)命名空间包含了运行内核的名称、版本、底层体系结构类型等信息</p>
<blockquote>
<p>unshare –uts<br>hostname<br>hostname test<br>hostname</p>
</blockquote>
<p>查看ns中的hostname和主机上的name<br>分别为<code>test</code>和<code>edunode1</code></p>
<h3 id="隔离User"><a href="#隔离User" class="headerlink" title="隔离User"></a>隔离User</h3><p>隔离user namespace</p>
<blockquote>
<p>unshare –user</p>
</blockquote>
<p>可以通过-r参数，把新的namespace中的root用户映射成宿主机上的用户，例如，把ns中的用户映射为宿主机的root</p>
<blockquote>
<p>unshare –user -r root</p>
</blockquote>
<h3 id="隔离PID"><a href="#隔离PID" class="headerlink" title="隔离PID"></a>隔离PID</h3><blockquote>
<p>unshare –pid</p>
</blockquote>
<p>观察主机上的进程<br><img src="/2021/08/21/Kubernetes/Docker/namespace/pid_host.png"></p>
<p>观察PID namespace中的进程<br><img src="/2021/08/21/Kubernetes/Docker/namespace/pid_ns.png"></p>
<h3 id="隔离Network"><a href="#隔离Network" class="headerlink" title="隔离Network"></a>隔离Network</h3><ol>
<li>创建netns<blockquote>
<p>ip netns add ns1</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ip netns list</p>
</blockquote>
<ol start="2">
<li>查看ns1中的网络，通过ip netns exec执行在ns中执行响应命令</li>
</ol>
<blockquote>
<p>ip netns exec ns1 ip addr</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ip_netns_ipaddr.png"></p>
<ol start="3">
<li>测试网络连通性<blockquote>
<p>ip netns exec ns1 ping 10.6.8.113</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ip_netns_ping.png"></p>
<h4 id="通过veth-pair与宿主机、其他ns进行网络通信"><a href="#通过veth-pair与宿主机、其他ns进行网络通信" class="headerlink" title="通过veth pair与宿主机、其他ns进行网络通信"></a>通过veth pair与宿主机、其他ns进行网络通信</h4><ol>
<li>创建veth pair</li>
</ol>
<blockquote>
<p>ip link add veth0 type veth peer name veth1</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/create_veth_pair.png"></p>
<ol start="2">
<li><p>将veth0或者veth1移动到ns1中</p>
<blockquote>
<p>ip link set veth1 netns ns1</p>
</blockquote>
</li>
<li><p>配置ip</p>
<blockquote>
<p>ip netns exec ns1 ifconfig veth1 192.168.10.100/24</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ifconfig veth0 192.168.10.101/24</p>
</blockquote>
<ol start="4">
<li>将网卡启动<blockquote>
<p>ip netns exec ns1 ifconfig veth1 up</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/vethpeer_in_ns.png"></p>
<blockquote>
<p>ifconfig veth0</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/vethpeer_in_host.png"></p>
<ol start="5">
<li>测试<blockquote>
<p>ip netns exec ns1 ping 192.168.10.101</p>
</blockquote>
</li>
</ol>
<p>同理，可将veth peer分别放在两个netns中进行联通</p>
<h4 id="通过bridge中转"><a href="#通过bridge中转" class="headerlink" title="通过bridge中转"></a>通过bridge中转</h4><p>实际使用中，不可能每2个不同的ns都进行一次veth pair配置，这时就需要Linux Bridge来做转发，将veth pair中的一个veth peer绑定到ns中，另一端绑定到bridge上。</p>
<ol>
<li>创建两个netns，和两对veth pair<blockquote>
<p>ip netns add ns0<br>ip netns add ns1</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ip link add veth0 type veth peer name br-veth0<br>ip link add veth1 type veth peer name br-veth1</p>
</blockquote>
<ol start="2">
<li>创建bridge，并启动网桥<blockquote>
<p>brctl addbr br0</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ip link set br0 up</p>
</blockquote>
<ol start="3">
<li>将veth pair中的一端分别加入到ns中，另一端放到bridge上</li>
</ol>
<p>将veth0放入ns0中，并配置ip</p>
<blockquote>
<p>ip link set veth0 netns ns0<br>ip netns exec ns0 ifconfig veth0 192.168.10.100/24 up<br>ip netns exec ns0 ip link set lo up</p>
</blockquote>
<p>将br-veth0绑定到网桥br0上，并启动br-veth0</p>
<blockquote>
<p>brctl addif br0 br-veth0<br>ip link set br-veth0 up</p>
</blockquote>
<p>将veth1放入ns1中，并配置ip，启动lo</p>
<blockquote>
<p>ip link set veth1 netns ns1<br>ip netns exec ns1 ifconfig veth1 192.168.10.101/24 up<br>ip netns exec ns1 ip link set lo up</p>
</blockquote>
<p>将br-veth1绑定到网桥br0上，并启动br-veth1</p>
<blockquote>
<p>brctl addif br0 br-veth1<br>ip link set br-veth1 up</p>
</blockquote>
<p>通过<code>brctl show</code>查看网桥<br><img src="/2021/08/21/Kubernetes/Docker/namespace/bridge.png"></p>
<ol start="4">
<li>连通性测试<blockquote>
<p>ip netns exec ns0 ping 192.168.10.101<br><img src="/2021/08/21/Kubernetes/Docker/namespace/connected.png"></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>apiserver启动分析</title>
    <url>/2021/08/30/Kubernetes/K8S/kube-apiserver%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E5%95%A5/</url>
    <content><![CDATA[<h1 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h1><p>apiserver是k8s的中心组件，它以RESTful API的形式提供了各类资源对象的操作接口。其他组件或者客户端(如kubectl)都会去调用它。apiserver支持同时提供https(默认监听6443端口)和http(默认监听8080端口)。其中http API是非安全结构，不做任何认证授权机制。</p>
<p>它的主要功能是：</p>
<ol>
<li>认证授权<ul>
<li> 通过认证插件<strong>认证客户端</strong>：客户端发送请求，apiserver通过配置的一个或多个认证插件，轮流调用这些插件，直到有一个插件认证通过。主要通过检查HTTP请求实现，可以从HTTP头或者客户端证书中获取用户信息，插件获得客户端的用户名、用户id和归属组来进行认证。</li>
<li> 通过授权插件<strong>授权客户端</strong>：apiserver通过配置一个或多个授权插件，对已经认证的客户端进行认证，决定其是否能对请求的资源执行相应的操作</li>
<li> 通过准入控制插件<strong>验证修改资源请求</strong>：当客户端请求尝试<strong>创建、修改、删除</strong>资源时，请求需要经过准入控。制插件的验证。apiserver会配置多个准入控制插件，<strong>请求需要经过所有准入控制插件的验证</strong>。如果请求是读取数据，则不会做准入控制验证。</li>
</ul>
</li>
<li>变更通知：<ul>
<li>客户端通过创建到apiserver的HTTP连接来监听资源变更，通过连接，客户端会接收到监听对象的一系列变更通知。当对象发生变化，apiserver会把新版本的对象发送至所有监听该对象的客户端。</li>
</ul>
</li>
<li>组件通信：<ul>
<li>k8s系统的组件，只能通过apiserver进行通信，组件间不会直接通信。<strong>apiserver是唯一与etcd通信的组件</strong>，其他组件不会与etcd做通信，而是通过与apiserver通信，来进行对资源对象的修改。</li>
</ul>
</li>
</ol>
<h2 id="kube-apiserver架构"><a href="#kube-apiserver架构" class="headerlink" title="kube-apiserver架构"></a>kube-apiserver架构</h2><p>apiserver提供了3种HTTP Server服务，APIExtensionsServer、KubeAPIServer、AggregatorServer。不同服务的应用场景不同，提供的资源也不同。</p>
<ul>
<li>APIExtensionsServer：API扩展服务(扩展器)。提供了CRD自定义服务，可通过CRD对Kubernetes资源进行扩展。该服务通过CustomResourceDefinitions对象进行管理，并通过extensionsapiserver.Scheme资源注册表管理CRD相关资源。</li>
<li>KubeAPIServer：API核心服务。提供了Kubernetes内置核心资源服务，不允许开发者随意更改相关资源。API核心服务通过Master对象进行管理，并通过legacyscheme.Scheme资源注册表管理Master相关资源。</li>
<li>AggregatorServer：将用户扩展的API注册到apiserver，为其提供服务发现。通过API聚合层APIAggregator(AA)将扩展API的访问请求转发到用户扩展的服务上。</li>
</ul>
<hr>
<ul>
<li>GenericAPIServer：APIExtensionsServer、KubeAPIServer、AggregatorServer都基于GenericAPIServer进行创建。通过GenericAPIServer可以将Kubernetes资源与REST API进行映射。</li>
</ul>
<h1 id="apiserver启动流程分析"><a href="#apiserver启动流程分析" class="headerlink" title="apiserver启动流程分析"></a>apiserver启动流程分析</h1><p>相关源码参照kubernetes 1.20.4</p>
<h2 id="注册k8s所支持的资源"><a href="#注册k8s所支持的资源" class="headerlink" title="注册k8s所支持的资源"></a>注册k8s所支持的资源</h2><p>首先，kubernetes支持的资源需要注册到Scheme资源注册表中，启动时，才能从Scheme中拿到资源信息，并启动、运行AggregatorServer、APIExtensionsServer、KubeAPIServer。资源的注册，是通过Go的import和init触发的。</p>
<ol>
<li><code>cmd/kube-apiserver/app/server.go</code>中，导入了<code>&quot;k8s.io/kubernetes/pkg/api/legacyscheme&quot;</code>包，该包中定义了全局的<strong>Scheme资源注册表</strong>、<strong>Codec编解码器</strong>、<strong>ParameterCodec参数编解码器</strong>。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> legacyscheme</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;k8s.io/apimachinery/pkg/runtime/serializer&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  Scheme = runtime.NewScheme()</span><br><span class="line">  Codecs = serializer.NewCodecFactory(Scheme)</span><br><span class="line">  ParameterCodec = runtime.NewParameterCodec(Scheme)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>通过导入<code>&quot;k8s.io/kubernetes/pkg/controlplane&quot;</code>注册资源。controlplane导入了apiserver支持的API groups包，通过导入包的机制，触发其初始化函数，进行资源的注册。例如，在controlplane的<code>import_known_versions.go</code>，导入了<code>k8s.io/kubernetes/pkg/apis/admission/install</code>。这个install文件实际上就是将相应的资源通过AddToScheme方法，添加到Scheme资源注册表中。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> install</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line">  utilruntime <span class="string">&quot;k8s.io/apimachinery/pkg/util/runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;k8s.io/kubernetes/pkg/api/legacyscheme&quot;</span></span><br><span class="line">  <span class="string">&quot;k8s.io/kubernetes/pkg/apis/admission&quot;</span></span><br><span class="line">  v1 <span class="string">&quot;k8s.io/kubernetes/pkg/apis/admission/v1&quot;</span></span><br><span class="line">  <span class="string">&quot;k8s.io/kubernetes/pkg/apis/admission/v1beta1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  Install(legacyscheme.Scheme)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Install registers the API group and adds types to a scheme</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Install</span><span class="params">(scheme *runtime.Scheme)</span></span> &#123;</span><br><span class="line">  utilruntime.Must(admission.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(v1beta1.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(v1.AddToScheme(scheme))</span><br><span class="line">  utilruntime.Must(scheme.SetVersionPriority(v1.SchemeGroupVersion, v1beta1.SchemeGroupVersion))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Cobra命令行解析"><a href="#Cobra命令行解析" class="headerlink" title="Cobra命令行解析"></a>Cobra命令行解析</h2><p>apiserver.go的main方法主要是通过cobra进行执行启动命令。通过调用NewAPIServerCommand()方法，对apiserver配置进行默认值填充和验证。在该方法中，会通过NewServerRunOptions配置参数默认值，然后将options传给command。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">  <span class="comment">// 资源组件配置默认值填充</span></span><br><span class="line">  s := options.NewServerRunOptions()</span><br><span class="line">  <span class="comment">// 构建命令行命令，将参数传递给command</span></span><br><span class="line">  cmd := &amp;cobra.Command&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 设置apiserver默认启动的options</span></span><br><span class="line">    completedOptions, err := Complete(s)</span><br><span class="line">    <span class="keyword">if</span> errs := completedOptions.Validate(); <span class="built_in">len</span>(errs) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cobra生成的命令实现的功能方法</span></span><br><span class="line">    RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">return</span> Run(completedOptions, genericapiserver.SetupSignalHandler())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> cmd</span><br></pre></td></tr></table></figure>
<p>apiserver的main方法中，最终会调用cobra.Execute()执行这个命令进行启动。启动时，cobra会调用Run()方法，Run()方法主要做了3件事<code>server:=CreateServerChain</code>、<code>server.PrepareRun</code>和<code>server.Run</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	command := app.NewAPIServerCommand()</span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建ServerChain"><a href="#创建ServerChain" class="headerlink" title="创建ServerChain"></a>创建ServerChain</h2><pre><code>CreateServerChain主要对KubeAPIServer、APIExtensionServer、AggregatorServer进行了创建。
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateServerChain</span><span class="params">(completedOptions completedServerRunOptions, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(*aggregatorapiserver.APIAggregator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 根据options的SSHUser和SSHKeyfile，与Node进行连接</span></span><br><span class="line">	nodeTunneler, proxyTransport, err := CreateNodeDialer(completedOptions)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建运行apiserver需要的资源</span></span><br><span class="line">	kubeAPIServerConfig, serviceResolver, pluginInitializer, err := CreateKubeAPIServerConfig(completedOptions, nodeTunneler, proxyTransport)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建APIExtensionServer需要的资源</span></span><br><span class="line">	apiExtensionsConfig, err := createAPIExtensionsConfig(*kubeAPIServerConfig.GenericConfig, kubeAPIServerConfig.ExtraConfig.VersionedInformers, pluginInitializer, completedOptions.ServerRunOptions, completedOptions.MasterCount,</span><br><span class="line">		serviceResolver, webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, kubeAPIServerConfig.GenericConfig.EgressSelector, kubeAPIServerConfig.GenericConfig.LoopbackClientConfig))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建APIExtensionServer</span></span><br><span class="line">	apiExtensionsServer, err := createAPIExtensionsServer(apiExtensionsConfig, genericapiserver.NewEmptyDelegate())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建KubeAPIServer</span></span><br><span class="line">	kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建AggregatorServer需要的资源</span></span><br><span class="line">	aggregatorConfig, err := createAggregatorConfig(*kubeAPIServerConfig.GenericConfig, completedOptions.ServerRunOptions, kubeAPIServerConfig.ExtraConfig.VersionedInformers, serviceResolver, proxyTransport, pluginInitializer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建AggregatorServer</span></span><br><span class="line">	aggregatorServer, err := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// we don&#x27;t need special handling for innerStopCh because the aggregator server doesn&#x27;t create any go routines</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="创建通用配置"><a href="#创建通用配置" class="headerlink" title="创建通用配置"></a>创建通用配置</h3><p>ServerRunOptions包含了apiserver启动需要的所有参数，主要配置主要包括：</p>
<ul>
<li>genericoptions，比如Etcd、SecureServing、Audit、Features等</li>
<li>kubeoptions,Admission、Authentication、Authorization、CloudProvider等</li>
<li>metrics：采集的配置</li>
<li>logs：日志的配置</li>
<li>kubeletConfig：kubeletclient的config，比如port,node的hostname,ip，连接超时时间等</li>
<li>SSHKeyfile</li>
<li>SSHUser</li>
<li>ProxyClientCertFile</li>
<li>ProxyClientKeyFile</li>
</ul>
<p>CreateKubeAPIServerConfig主要完成apiserver的基础配置，这些配置信息来源于<code>kube-apiserver.yaml</code>中的<code>command</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-apiserver/app/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateKubeAPIServerConfig</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	s completedServerRunOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">	nodeTunneler tunneler.Tunneler,</span></span></span><br><span class="line"><span class="params"><span class="function">	proxyTransport *http.Transport,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	*controlplane.Config,</span></span></span><br><span class="line"><span class="params"><span class="function">	aggregatorapiserver.ServiceResolver,</span></span></span><br><span class="line"><span class="params"><span class="function">	[]admission.PluginInitializer,</span></span></span><br><span class="line"><span class="params"><span class="function">	error,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 根据配置信息，初始化genericConfig等信息</span></span><br><span class="line">	genericConfig, versionedInformers, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory, err := buildGenericConfig(s.ServerRunOptions, proxyTransport)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 存储配置</span></span><br><span class="line">	<span class="keyword">if</span> _, port, err := net.SplitHostPort(s.Etcd.StorageConfig.Transport.ServerList[<span class="number">0</span>]); err == <span class="literal">nil</span> &amp;&amp; port != <span class="string">&quot;0&quot;</span> &amp;&amp; <span class="built_in">len</span>(port) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := utilwait.PollImmediate(etcdRetryInterval, etcdRetryLimit*etcdRetryInterval, preflight.EtcdConnection&#123;ServerList: s.Etcd.StorageConfig.Transport.ServerList&#125;.CheckEtcdServers); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error waiting for etcd connection: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// ip范围设置</span></span><br><span class="line">	serviceIPRange, apiServerServiceIP, err := controlplane.ServiceIPRange(s.PrimaryServiceClusterIPRange)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	config := &amp;controlplane.Config&#123;</span><br><span class="line">		GenericConfig: genericConfig,</span><br><span class="line">		ExtraConfig: controlplane.ExtraConfig&#123;</span><br><span class="line">			......</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略了其他配置</span></span><br><span class="line">	.......</span><br><span class="line">	<span class="keyword">return</span> config, serviceResolver, pluginInitializers, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建APIExtensionsServer"><a href="#创建APIExtensionsServer" class="headerlink" title="创建APIExtensionsServer"></a>创建APIExtensionsServer</h3><h4 id="逻辑概述"><a href="#逻辑概述" class="headerlink" title="逻辑概述"></a>逻辑概述</h4><ol>
<li>通过c.GenericConfig.New()创建一个名为<code>apiextensions-apiserver</code>的genericServer。            <ol>
<li>创建http请求处理链，用作对请求的处理，一般用来进行filter操作，比如身份验证和授权。</li>
<li>实例化一个<code>genericAPIServer</code>对象<code>s</code>，genericAPIServer</li>
<li>创建并将SharedInformerFactory添加到<code>s</code>的PostStartHook</li>
<li>创建将对请求的限流添加到<code>s</code>的PostStartHook</li>
<li>创建将healthz检测添加到<code>s</code>的PostStartHook</li>
<li>通过<code>installAPI</code>，将api暴露</li>
</ol>
</li>
<li>创建<code>CustomResourceDefinitions(CRD)</code>对象。</li>
<li>实例化<code>GroupName</code>为<code>apiextensions.k8s.io</code>的<code>APIGroupInfo</code>，只对<code>apiextensions.k8s.io</code>的资源进行管理。</li>
<li>为<code>APIGroupInfo</code>添加<code>RESTStorage</code>，<code>RESTStorage</code>通过<code>Storage Backend</code>访问etcd。</li>
<li>通过<code>s.GenericAPIServer.InstallAPIGroup</code>将CRD的资源服务加入到<code>gorestful container</code>中。其调用链为”InstallAPIGroup-&gt;InstallAPIGroups-&gt;InstallAPIResources-&gt;InstallREST-&gt;APIInstaller.Install”。大体逻辑为遍历<code>APIGroupInfo</code>，注册<code>APIGroup</code>。<code>InstallAPIGroup</code>遍历时将Group、Resource、Version，与路径<code>/apis</code>封装为<code>APIGroupVersion</code>。然后调用<code>InstallREST</code>方法，<code>InstallREST</code>调用<code>Install</code>将遍历<code>APIGroupInfo</code>，根据rest.Storage确定APIGroupInfo的<code>Verbs</code>（GET、WATCH、CREATE、DELETE、UPDATE等）,<code>APIGroupInfo</code>进行绑定，然后将其封装为<code>APIResource</code>。通过<code>Verbs</code>确定能对资源做哪些操作，再将这些操作的path和http请求类型，请求处理的handler，注册为一条条的<code>route</code>记录。然后再将routes放到<code>webseivice</code>中，通过<code>DiscoveryGroupManager</code>对该<code>webseivice</code>设置服务发现，最后将<code>webservice</code>放到<code>gorestful container</code>中。</li>
<li>定义CRD的<code>ClientSet</code>，并为其创建<code>SharedInformerFactory</code></li>
<li>定义crdHandler，为暴露的api注册handler，包括crdInformer的AddFun、UpdateFunc、DeleteFunc等</li>
<li>定义对clientset的一系列controller控制器</li>
<li>将informer和controller添加到PostStartHook中。PostStartHookFunc是一个钩子函数，在server启动时触发。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*CustomResourceDefinitions, error)</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 创建genericServer</span></span><br><span class="line">	genericServer, err := c.GenericConfig.New(<span class="string">&quot;apiextensions-apiserver&quot;</span>, delegationTarget)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">// 实例化CRD，CRD中包括了GenericServer和SharedInformerFactory</span></span><br><span class="line">	s := &amp;CustomResourceDefinitions&#123;</span><br><span class="line">		GenericAPIServer: genericServer,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	apiResourceConfig := c.GenericConfig.MergedResourceConfig</span><br><span class="line">  	<span class="comment">// 实例化APIGroupInfo，将GroupName设置为apiextensions.k8s.io</span></span><br><span class="line">	apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(apiextensions.GroupName, Scheme, metav1.ParameterCodec, Codecs)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分别为v1.apiextensions和v1beta.apiextensions的apiGroupInfo添加RESTStorage。用于与etcd交互的</span></span><br><span class="line">	<span class="keyword">if</span> apiResourceConfig.VersionEnabled(v1beta1.SchemeGroupVersion) &#123;</span><br><span class="line">		storage := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;&#125;</span><br><span class="line">		customResourceDefinitionStorage, err := customresourcedefinition.NewREST(Scheme, c.GenericConfig.RESTOptionsGetter)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		storage[<span class="string">&quot;customresourcedefinitions&quot;</span>] = customResourceDefinitionStorage</span><br><span class="line">		storage[<span class="string">&quot;customresourcedefinitions/status&quot;</span>] = customresourcedefinition.NewStatusREST(Scheme, customResourceDefinitionStorage)</span><br><span class="line">		apiGroupInfo.VersionedResourcesStorageMap[v1beta1.SchemeGroupVersion.Version] = storage</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> apiResourceConfig.VersionEnabled(v1.SchemeGroupVersion) &#123;</span><br><span class="line">    	......</span><br><span class="line">		apiGroupInfo.VersionedResourcesStorageMap[v1.SchemeGroupVersion.Version] = storage</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在路由中注册APIGroupInfo，对外暴露API</span></span><br><span class="line">	<span class="comment">// InstallAPIGroup方法直接返回s.InstallAPIGroups(apiGroupInfo)</span></span><br><span class="line">	<span class="keyword">if</span> err := s.GenericAPIServer.InstallAPIGroup(&amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为&#x27;/apis&#x27;资源组的service提供处理方法handler</span></span><br><span class="line">	crdHandler, err := NewCustomResourceDefinitionHandler(</span><br><span class="line">		versionDiscoveryHandler,</span><br><span class="line">		groupDiscoveryHandler,</span><br><span class="line">		s.Informers.Apiextensions().V1().CustomResourceDefinitions(),</span><br><span class="line">		delegateHandler,</span><br><span class="line">		c.ExtraConfig.CRDRESTOptionsGetter,</span><br><span class="line">		c.GenericConfig.AdmissionControl,</span><br><span class="line">		establishingController,</span><br><span class="line">		c.ExtraConfig.ServiceResolver,</span><br><span class="line">		c.ExtraConfig.AuthResolverWrapper,</span><br><span class="line">		c.ExtraConfig.MasterCount,</span><br><span class="line">		s.GenericAPIServer.Authorizer,</span><br><span class="line">		c.GenericConfig.RequestTimeout,</span><br><span class="line">		time.Duration(c.GenericConfig.MinRequestTimeout)*time.Second,</span><br><span class="line">		apiGroupInfo.StaticOpenAPISpec,</span><br><span class="line">		c.GenericConfig.MaxRequestBodyBytes,</span><br><span class="line">	)</span><br><span class="line">	s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(<span class="string">&quot;/apis&quot;</span>, crdHandler)</span><br><span class="line">	s.GenericAPIServer.Handler.NonGoRestfulMux.HandlePrefix(<span class="string">&quot;/apis/&quot;</span>, crdHandler)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 定义controller，CRD用来处理请求</span></span><br><span class="line">	discoveryController := NewDiscoveryController(s.Informers.Apiextensions().V1().CustomResourceDefinitions(), versionDiscoveryHandler, groupDiscoveryHandler)</span><br><span class="line">	namingController := status.NewNamingConditionController(s.Informers.Apiextensions().V1().CustomResourceDefinitions(), crdClient.ApiextensionsV1())</span><br><span class="line">	nonStructuralSchemaController := nonstructuralschema.NewConditionController(s.Informers.Apiextensions().V1().CustomResourceDefinitions(), crdClient.ApiextensionsV1())</span><br><span class="line">	apiApprovalController := apiapproval.NewKubernetesAPIApprovalPolicyConformantConditionController(s.Informers.Apiextensions().V1().CustomResourceDefinitions(), crdClient.ApiextensionsV1())</span><br><span class="line">	finalizingController := finalizer.NewCRDFinalizer(</span><br><span class="line">		s.Informers.Apiextensions().V1().CustomResourceDefinitions(),</span><br><span class="line">		crdClient.ApiextensionsV1(),</span><br><span class="line">		crdHandler,</span><br><span class="line">	)</span><br><span class="line">	openapiController := openapicontroller.NewController(s.Informers.Apiextensions().V1().CustomResourceDefinitions())</span><br><span class="line">	<span class="comment">// controller和informer添加到PostStartHook中，在server启动的时候，运行Controller</span></span><br><span class="line">	s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-apiextensions-informers&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		s.Informers.Start(context.StopCh)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-apiextensions-controllers&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> s.GenericAPIServer.OpenAPIVersionedService != <span class="literal">nil</span> &amp;&amp; s.GenericAPIServer.StaticOpenAPISpec != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> openapiController.Run(s.GenericAPIServer.StaticOpenAPISpec, s.GenericAPIServer.OpenAPIVersionedService, context.StopCh)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> namingController.Run(context.StopCh)</span><br><span class="line">		<span class="keyword">go</span> establishingController.Run(context.StopCh)</span><br><span class="line">		<span class="keyword">go</span> nonStructuralSchemaController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">		<span class="keyword">go</span> apiApprovalController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">		<span class="keyword">go</span> finalizingController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line"></span><br><span class="line">		discoverySyncedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">go</span> discoveryController.Run(context.StopCh, discoverySyncedCh)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-context.StopCh:</span><br><span class="line">		<span class="keyword">case</span> &lt;-discoverySyncedCh:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;crd-informer-synced&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> wait.PollImmediateUntil(<span class="number">100</span>*time.Millisecond, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> s.Informers.Apiextensions().V1().CustomResourceDefinitions().Informer().HasSynced(), <span class="literal">nil</span></span><br><span class="line">		&#125;, context.StopCh)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建GenericServer"><a href="#创建GenericServer" class="headerlink" title="创建GenericServer"></a>创建GenericServer</h4><ol>
<li>配置项检查</li>
<li>定义用于身份验证和授权的<code>handlerChainBuilder</code>请求处理链</li>
<li>创建handler，handler用于创建<code>gorestful container</code>，配置路由并将handler与路由关联。</li>
<li>创建<code>SharedInformerFactory</code>，用于给资源创建informer。并将其添加到PostStartrHook中</li>
<li>创建用于对资源请求的隔离、限流、健康检查的处理，并添加到PostStartHook中。</li>
<li>通过InstallAPI，进行资源暴露<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/server/config.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(name <span class="keyword">string</span>, delegationTarget DelegationTarget)</span> <span class="params">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// completedConfig检查</span></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// go-restful请求处理链，用来处理身份验证和授权等过滤</span></span><br><span class="line">	handlerChainBuilder := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.BuildHandlerChainFunc(handler, c.Config)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// apiServer用来处理请求的handler</span></span><br><span class="line">	apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class="line">	<span class="comment">// 根据config，配置genericAPIServer，并将apiServerHandler绑定到crd.genericAPIServer中</span></span><br><span class="line">	s := &amp;GenericAPIServer&#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加hook</span></span><br><span class="line">	<span class="keyword">for</span> name, preconfiguredPostStartHook := <span class="keyword">range</span> c.PostStartHooks &#123;</span><br><span class="line">		<span class="keyword">if</span> err := s.AddPostStartHook(name, preconfiguredPostStartHook.hook); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建informers</span></span><br><span class="line">	genericApiServerHookName := <span class="string">&quot;generic-apiserver-start-informers&quot;</span></span><br><span class="line">	<span class="keyword">if</span> c.SharedInformerFactory != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !s.isPostStartHookRegistered(genericApiServerHookName) &#123;</span><br><span class="line">			err := s.AddPostStartHook(genericApiServerHookName, <span class="function"><span class="keyword">func</span><span class="params">(context PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">				<span class="comment">// context.StopCh给informer的channel提供信息</span></span><br><span class="line">				c.SharedInformerFactory.Start(context.StopCh)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 添加healthz检查</span></span><br><span class="line">		err := s.addReadyzChecks(healthz.NewInformerSyncHealthz(c.SharedInformerFactory))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> priorityAndFairnessConfigConsumerHookName = <span class="string">&quot;priority-and-fairness-config-consumer&quot;</span></span><br><span class="line">	<span class="keyword">if</span> s.isPostStartHookRegistered(priorityAndFairnessConfigConsumerHookName) &#123;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &#123;</span><br><span class="line">		err := s.AddPostStartHook(priorityAndFairnessConfigConsumerHookName, <span class="function"><span class="keyword">func</span><span class="params">(context PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">go</span> c.FlowControl.MaintainObservations(context.StopCh)</span><br><span class="line">			<span class="keyword">go</span> c.FlowControl.Run(context.StopCh)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// TODO(yue9944882): plumb pre-shutdown-hook for request-management system?</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Not requested to run hook %s&quot;</span>, priorityAndFairnessConfigConsumerHookName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 添加APF对请求进行分类和隔离(限流机制，保护api被恶意请求消耗资源然后死掉)</span></span><br><span class="line">		<span class="keyword">const</span> priorityAndFairnessFilterHookName = <span class="string">&quot;priority-and-fairness-filter&quot;</span></span><br><span class="line">		<span class="keyword">if</span> !s.isPostStartHookRegistered(priorityAndFairnessFilterHookName) &#123;</span><br><span class="line">			err := s.AddPostStartHook(priorityAndFairnessFilterHookName, <span class="function"><span class="keyword">func</span><span class="params">(context PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">				genericfilters.StartPriorityAndFairnessWatermarkMaintenance(context.StopCh)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 默认添加max-in-flight，避免受到CPU和内存过载的影响</span></span><br><span class="line">		<span class="keyword">const</span> maxInFlightFilterHookName = <span class="string">&quot;max-in-flight-filter&quot;</span></span><br><span class="line">		<span class="keyword">if</span> !s.isPostStartHookRegistered(maxInFlightFilterHookName) &#123;</span><br><span class="line">			err := s.AddPostStartHook(maxInFlightFilterHookName, <span class="function"><span class="keyword">func</span><span class="params">(context PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">				genericfilters.StartMaxInFlightWatermarkMaintenance(context.StopCh)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加healthz检查</span></span><br><span class="line">	<span class="keyword">for</span> _, delegateCheck := <span class="keyword">range</span> delegationTarget.HealthzChecks() &#123;</span><br><span class="line">		skip := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> _, existingCheck := <span class="keyword">range</span> c.HealthzChecks &#123;</span><br><span class="line">			<span class="keyword">if</span> existingCheck.Name() == delegateCheck.Name() &#123;</span><br><span class="line">				skip = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> skip &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		s.AddHealthChecks(delegateCheck)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// api的path集合</span></span><br><span class="line">	s.listedPathProvider = routes.ListedPathProviders&#123;s.listedPathProvider, delegationTarget&#125;</span><br><span class="line">	<span class="comment">// 暴露api</span></span><br><span class="line">	installAPI(s, c.Config)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// use the UnprotectedHandler from the delegation target to ensure that we don&#x27;t attempt to double authenticator, authorize,</span></span><br><span class="line">	<span class="comment">// or some other part of the filter chain in delegation cases.</span></span><br><span class="line">	<span class="keyword">if</span> delegationTarget.UnprotectedHandler() == <span class="literal">nil</span> &amp;&amp; c.EnableIndex &#123;</span><br><span class="line">		s.Handler.NonGoRestfulMux.NotFoundHandler(routes.IndexLister&#123;</span><br><span class="line">			StatusCode:   http.StatusNotFound,</span><br><span class="line">			PathProvider: s.listedPathProvider,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="InstallAPI"><a href="#InstallAPI" class="headerlink" title="InstallAPI"></a>InstallAPI</h5></li>
</ol>
<ul>
<li><code>routes.Index&#123;&#125;.Install()</code>，暴露了<code>&quot;/&quot;</code>,<code>&quot;/index.html&quot;</code>，用于获取apiservice索引页面。可以通过浏览器访问”<code>http://ip:8080</code>“查看。</li>
<li><code>routes.Profiling&#123;&#125;.Install()</code>，暴露了<code>&quot;/debug/pprof&quot;</code>性能分析页面。包含的path有:<code>&quot;/debug/pprof/&quot;</code>,<code>&quot;/debug/pprof/profile&quot;</code>,<code>&quot;/debug/pprof/profile&quot;</code>,<code>&quot;/debug/pprof/profile&quot;</code>。可以通过浏览器访问”<code>http://ip:8080/debug/pprof/</code>“查看。</li>
<li><code>routes.MetricsWithReset&#123;&#125;.Install()</code>或<code>routes.DefaultMetrics&#123;&#125;.Install()</code>，暴露了<code>&quot;/metrics&quot;</code>。可以通过浏览器访问”<code>http://ip:8080/</code>“查看。</li>
<li>添加服务注册管理</li>
<li>添加APF流量控制机制<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apiserver/pkg/server/config.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">installAPI</span><span class="params">(s *GenericAPIServer, c *Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.EnableIndex &#123;</span><br><span class="line">		routes.Index&#123;&#125;.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.EnableProfiling &#123;</span><br><span class="line">		routes.Profiling&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">		<span class="keyword">if</span> c.EnableContentionProfiling &#123;</span><br><span class="line">			goruntime.SetBlockProfileRate(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		routes.DebugFlags&#123;&#125;.Install(s.Handler.NonGoRestfulMux, <span class="string">&quot;v&quot;</span>, routes.StringFlagPutHandler(logs.GlogSetter))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.EnableMetrics &#123;</span><br><span class="line">		<span class="keyword">if</span> c.EnableProfiling &#123;</span><br><span class="line">			routes.MetricsWithReset&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			routes.DefaultMetrics&#123;&#125;.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	routes.Version&#123;Version: c.Version&#125;.Install(s.Handler.GoRestfulContainer)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.EnableDiscovery &#123;</span><br><span class="line">		s.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &amp;&amp; feature.DefaultFeatureGate.Enabled(features.APIPriorityAndFairness) &#123;</span><br><span class="line">		c.FlowControl.Install(s.Handler.NonGoRestfulMux)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InstallAPIGroups的主要处理"><a href="#InstallAPIGroups的主要处理" class="headerlink" title="InstallAPIGroups的主要处理"></a>InstallAPIGroups的主要处理</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InstallAPIGroups的主要处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">InstallAPIGroups</span><span class="params">(apiGroupInfos ...*APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	openAPIModels, err := s.getOpenAPIModels(APIGroupPrefix, apiGroupInfos...)</span><br><span class="line">    <span class="keyword">for</span> _, apiGroupInfo := <span class="keyword">range</span> apiGroupInfos &#123;</span><br><span class="line">      <span class="keyword">if</span> err := s.installAPIResources(APIGroupPrefix, apiGroupInfo, openAPIModels); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to install api resources: %v&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">      s.DiscoveryGroupManager.AddGroup(apiGroup)</span><br><span class="line">      s.Handler.GoRestfulContainer.Add(discovery.NewAPIGroupHandler(s.Serializer, apiGroup).WebService())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="installAPIResources"><a href="#installAPIResources" class="headerlink" title="installAPIResources"></a>installAPIResources</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//k8s.io/apiserver/pkg/server/genericapiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">installAPIResources</span><span class="params">(apiPrefix <span class="keyword">string</span>, apiGroupInfo *APIGroupInfo, openAPIModels openapiproto.Models)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> resourceInfos []*storageversion.ResourceInfo</span><br><span class="line">	<span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.PrioritizedVersions &#123;</span><br><span class="line">		......</span><br><span class="line">		</span><br><span class="line">		apiGroupVersion := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">		<span class="comment">// 注册restful api的处理方法</span></span><br><span class="line">		r, err := apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer)</span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">		resourceInfos = <span class="built_in">append</span>(resourceInfos, r...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getAPIGroupVersion"><a href="#getAPIGroupVersion" class="headerlink" title="getAPIGroupVersion"></a>getAPIGroupVersion</h5>将<code>APIGroupInfo</code>封装为<code>APIGroupVersion</code>，为其添加一个<code>RESTful Storage</code>。这个Storage主要用于存放该组资源的信息，从版本到资源再到存储的映射。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apiserver/pkg/server/genericapiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">getAPIGroupVersion</span><span class="params">(apiGroupInfo *APIGroupInfo, groupVersion schema.GroupVersion, apiPrefix <span class="keyword">string</span>)</span> *<span class="title">genericapi</span>.<span class="title">APIGroupVersion</span></span> &#123;</span><br><span class="line">	storage := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version] &#123;</span><br><span class="line">		storage[strings.ToLower(k)] = v</span><br><span class="line">	&#125;</span><br><span class="line">	version := s.newAPIGroupVersion(apiGroupInfo, groupVersion)</span><br><span class="line">	version.Root = apiPrefix</span><br><span class="line">	version.Storage = storage</span><br><span class="line">	<span class="keyword">return</span> version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="InstallREST"><a href="#InstallREST" class="headerlink" title="InstallREST"></a>InstallREST</h5><code>InstallREST</code>将<code>REST handlers</code>(storage, watch, proxy and redirect)注册到<code>RESTful Container</code>中。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/endpoints/groupversion.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *APIGroupVersion)</span> <span class="title">InstallREST</span><span class="params">(container *restful.Container)</span> <span class="params">([]*storageversion.ResourceInfo, error)</span></span> &#123;</span><br><span class="line">	prefix := path.Join(g.Root, g.GroupVersion.Group, g.GroupVersion.Version)</span><br><span class="line">	installer := &amp;APIInstaller&#123;</span><br><span class="line">		group:             g,</span><br><span class="line">		prefix:            prefix,</span><br><span class="line">		minRequestTimeout: g.MinRequestTimeout,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 为API resources注册handlers，同时创建一个restful.WebService，把handlers注册到WebService中。Install()调用registerResourceHandlers，为资源绑定action和path</span></span><br><span class="line">	apiResources, resourceInfos, ws, registrationErrors := installer.Install()</span><br><span class="line">	versionDiscoveryHandler := discovery.NewAPIVersionHandler(g.Serializer, g.GroupVersion, staticLister&#123;apiResources&#125;)</span><br><span class="line">	versionDiscoveryHandler.AddToWebService(ws)</span><br><span class="line">	<span class="comment">// 将webservice注册到container中</span></span><br><span class="line">	container.Add(ws)</span><br><span class="line">	<span class="keyword">return</span> removeNonPersistedResources(resourceInfos), utilerrors.NewAggregate(registrationErrors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="APIInstaller-Install-绑定资源的path和handler"><a href="#APIInstaller-Install-绑定资源的path和handler" class="headerlink" title="APIInstaller.Install()绑定资源的path和handler"></a>APIInstaller.Install()绑定资源的path和handler</h5><code>installer.Install()</code>调用<code>install.registerResourceHandlers()</code>，根据rest.Storage判断资源可以执行的操作，然后将其放入<code>actions</code>中，再对<code>actions</code>遍历，使用restful的RouteFunction为action创建handler。然后将action和handler注册到<code>route</code>中，再将<code>route</code>注册到<code>webservice</code>中。<code>InstallREST()</code>通过<code>container.Add(ws)</code>会把这个<code>ws</code>注册到<code>restful.Container</code>中。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIInstaller)</span> <span class="title">registerResourceHandlers</span><span class="params">(path <span class="keyword">string</span>, storage rest.Storage, ws *restful.WebService)</span> <span class="params">(*metav1.APIResource, *storageversion.ResourceInfo, error)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 为资源添加action</span></span><br><span class="line">	actions = appendIf(actions, action&#123;<span class="string">&quot;LIST&quot;</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isLister)</span><br><span class="line">		actions = appendIf(actions, action&#123;<span class="string">&quot;POST&quot;</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCreater)</span><br><span class="line">		actions = appendIf(actions, action&#123;<span class="string">&quot;DELETECOLLECTION&quot;</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCollectionDeleter)</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//  为action创建handler</span></span><br><span class="line">	<span class="keyword">for</span> _, action := <span class="keyword">range</span> actions &#123;</span><br><span class="line">		......</span><br><span class="line">		<span class="keyword">switch</span> action.Verb &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">			<span class="keyword">var</span> handler restful.RouteFunction</span><br><span class="line">			<span class="keyword">if</span> isGetterWithOptions &#123;</span><br><span class="line">				handler = restfulGetResourceWithOptions(getterWithOptions, reqScope, isSubresource)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				handler = restfulGetResource(getter, exporter, reqScope)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> needOverride &#123;</span><br><span class="line">				<span class="comment">// need change the reported verb</span></span><br><span class="line">				handler = metrics.InstrumentRouteFunc(verbOverrider.OverrideMetricsVerb(action.Verb), group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, handler)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, handler)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> enableWarningHeaders &#123;</span><br><span class="line">				handler = utilwarning.AddWarningsHandler(handler, warnings)</span><br><span class="line">			&#125;</span><br><span class="line">			doc := <span class="string">&quot;read the specified &quot;</span> + kind</span><br><span class="line">			<span class="comment">// </span></span><br><span class="line">			route := ws.GET(action.Path).To(handler).</span><br><span class="line">				Doc(doc).</span><br><span class="line">				Param(ws.QueryParameter(<span class="string">&quot;pretty&quot;</span>, <span class="string">&quot;If &#x27;true&#x27;, then the output is pretty printed.&quot;</span>)).</span><br><span class="line">				Operation(<span class="string">&quot;read&quot;</span>+namespaced+kind+strings.Title(subresource)+operationSuffix).</span><br><span class="line">				Produces(<span class="built_in">append</span>(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).</span><br><span class="line">				Returns(http.StatusOK, <span class="string">&quot;OK&quot;</span>, producedObject).</span><br><span class="line">				Writes(producedObject)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;LIST&quot;</span>:</span><br><span class="line">			......</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;PUT&quot;</span>:</span><br><span class="line">			......</span><br><span class="line">		......</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unrecognized action verb: %s&quot;</span>, action.Verb)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将route注册到webservice中</span></span><br><span class="line">		<span class="keyword">for</span> _, route := <span class="keyword">range</span> routes &#123;</span><br><span class="line">			route.Metadata(ROUTE_META_GVK, metav1.GroupVersionKind&#123;</span><br><span class="line">				Group:   reqScope.Kind.Group,</span><br><span class="line">				Version: reqScope.Kind.Version,</span><br><span class="line">				Kind:    reqScope.Kind.Kind,</span><br><span class="line">			&#125;)</span><br><span class="line">			route.Metadata(ROUTE_META_ACTION, strings.ToLower(action.Verb))</span><br><span class="line">			ws.Route(route)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> &amp;apiResource, resourceInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建KubeAPIServer"><a href="#创建KubeAPIServer" class="headerlink" title="创建KubeAPIServer"></a>创建KubeAPIServer</h3><code>kube-apiserver</code>的创建逻辑与创建<code>apiextensions-apiserver</code>类似，<code>kube-apiserver</code>主要是为了对<code>&quot;/api&quot;</code>和<code>&quot;/apis&quot;</code>下的资源进行注册暴露。<h4 id="逻辑概述-1"><a href="#逻辑概述-1" class="headerlink" title="逻辑概述"></a>逻辑概述</h4></li>
</ul>
<ol>
<li>通过<code>GenericConfig.New()</code>方法创建一个为<code>kube-apiserver</code>，方法逻辑与创建<code>apiextensions-apiserver</code>完全一致。</li>
<li>判断是否支持<code>logs</code>，支持的话，就添加<code>logs</code>的路由。</li>
<li>实例化<code>apiserver</code>对象<code>Instance</code>，将认证配置封装到<code>apiserver</code>对象中。</li>
<li>调用<code>InstallLegacyAPI</code>方法，注册apiserver的核心资源(core)，主要是<code>&quot;/api/v1&quot;</code>下的每个<code>resource</code>。核心资源的均声明于<code>k8s.io/client-go/kubernetes/typed/core/v1/</code>下。</li>
<li><code>[]RESTStorageProvider</code>中每一项<code>StorageProvider</code>在实例化时，都会创建一个带有<code>groupName</code>的<code>apiGroupInfo</code>，并为不同<code>version</code>创建Storage。将<code>[]RESTStorageProvider</code>传入<code>InstallAPIs</code>。</li>
<li>调用<code>InstallAPIs</code>方法中，遍历<code>RESTStorageProvider</code>列表，为每种资源封装<code>apiGroupInfo</code>，然后调用<code>InstallAPIGroups</code>将服务进行注册。</li>
<li>最后为<code>apiserver</code>添加用于身份认证、检测的<code>PostStartHook</code>。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/server/config.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*Instance, error)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 实例化kube-apiserver</span></span><br><span class="line">	s, err := c.GenericConfig.New(<span class="string">&quot;kube-apiserver&quot;</span>, delegationTarget)</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 注册logs路由</span></span><br><span class="line">	<span class="keyword">if</span> c.ExtraConfig.EnableLogsSupport &#123;</span><br><span class="line">		routes.Logs&#123;&#125;.Install(s.Handler.GoRestfulContainer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// beta v1.20，开启SA服务发现，用于SA的token验证。</span></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.ServiceAccountIssuerDiscovery) &#123;</span><br><span class="line">			md, err := serviceaccount.NewOpenIDMetadata(</span><br><span class="line">			c.ExtraConfig.ServiceAccountIssuerURL,</span><br><span class="line">			c.ExtraConfig.ServiceAccountJWKSURI,</span><br><span class="line">			c.GenericConfig.ExternalAddress,</span><br><span class="line">			c.ExtraConfig.ServiceAccountPublicKeys,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			......</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 注册apiserver提供JWKS的URL路径，该JWKS包含可用于签署Kubernetes服务帐户密钥的公钥。</span></span><br><span class="line">			routes.NewOpenIDMetadataServer(md.ConfigJSON, md.PublicKeysetJSON).</span><br><span class="line">				Install(s.Handler.GoRestfulContainer)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// apiserver实例包含genericAPIServer和认证配置（验证普通客户端的身份的ClientCA、用来确定用户名的头信息RequestHeaderUsernameHeaders、kube-apiserver用来确定组的头信息RequestHeaderGroupHeaders、用来确定user.extra的头文件RequestHeaderExtraHeaderPrefixes、允许充当前端代理的Subject主题RequestHeaderAllowedNames、用来验证前端代理的requesttheaderca）</span></span><br><span class="line">	m := &amp;Instance&#123;</span><br><span class="line">		GenericAPIServer:          s,</span><br><span class="line">		ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// LegacyAPI</span></span><br><span class="line">	<span class="keyword">if</span> c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class="line">		legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;</span><br><span class="line">			StorageFactory:              c.ExtraConfig.StorageFactory,</span><br><span class="line">			ProxyTransport:              c.ExtraConfig.ProxyTransport,</span><br><span class="line">			KubeletClientConfig:         c.ExtraConfig.KubeletClientConfig,</span><br><span class="line">			EventTTL:                    c.ExtraConfig.EventTTL,</span><br><span class="line">			ServiceIPRange:              c.ExtraConfig.ServiceIPRange,</span><br><span class="line">			SecondaryServiceIPRange:     c.ExtraConfig.SecondaryServiceIPRange,</span><br><span class="line">			ServiceNodePortRange:        c.ExtraConfig.ServiceNodePortRange,</span><br><span class="line">			LoopbackClientConfig:        c.GenericConfig.LoopbackClientConfig,</span><br><span class="line">			ServiceAccountIssuer:        c.ExtraConfig.ServiceAccountIssuer,</span><br><span class="line">			ExtendExpiration:            c.ExtraConfig.ExtendExpiration,</span><br><span class="line">			ServiceAccountMaxExpiration: c.ExtraConfig.ServiceAccountMaxExpiration,</span><br><span class="line">			APIAudiences:                c.GenericConfig.Authentication.APIAudiences,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每一种资源的RESTStorageProvider存放了其不同version和path.</span></span><br><span class="line">	restStorageProviders := []RESTStorageProvider&#123;</span><br><span class="line">		apiserverinternalrest.StorageProvider&#123;&#125;,</span><br><span class="line">		authenticationrest.RESTStorageProvider&#123;Authenticator: c.GenericConfig.Authentication.Authenticator, APIAudiences: c.GenericConfig.Authentication.APIAudiences&#125;,</span><br><span class="line">		authorizationrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer, RuleResolver: c.GenericConfig.RuleResolver&#125;,</span><br><span class="line">		autoscalingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		batchrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		certificatesrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		coordinationrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		discoveryrest.StorageProvider&#123;&#125;,</span><br><span class="line">		extensionsrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		networkingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		noderest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		policyrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		rbacrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorization.Authorizer&#125;,</span><br><span class="line">		schedulingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		storagerest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		flowcontrolrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		appsrest.StorageProvider&#123;&#125;,</span><br><span class="line">		admissionregistrationrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		eventsrest.RESTStorageProvider&#123;TTL: c.ExtraConfig.EventTTL&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  暴露api</span></span><br><span class="line">	<span class="keyword">if</span> err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.ExtraConfig.Tunneler != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.installTunneler(c.ExtraConfig.Tunneler, corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig).Nodes())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-cluster-authentication-info-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(hookContext genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(apiserverfeatures.APIServerIdentity) &#123;</span><br><span class="line">		m.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-kube-apiserver-identity-lease-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(hookContext genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">		m.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-kube-apiserver-identity-lease-garbage-collector&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(hookContext genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InstallLegacyAPI"><a href="#InstallLegacyAPI" class="headerlink" title="InstallLegacyAPI"></a>InstallLegacyAPI</h4></li>
<li>通过<code>NewLegacyRESTStorage</code>，声明一个资源组对象<code>apiGroupInfo</code>。然后为核心组的资源创建存储restStorage，比如通过调用<code>&#39;podstore.NewStorage&#39;</code>为pod资源创建一个<code>podStorage</code>，然后将其放入<code>restStorageMap</code>。最后将<code>apiGroupInfo</code>资源版本设置为v1，并将<code>restStorageMap</code>，赋值给核心组的<code>VersionedResourcesStorageMap``（VersionedResourcesStorageMap map[string]map[string]rest.Storage</code>，对外显示为<code>Version/Resource/RestStorage</code>），例如可以通过<code>&quot;http://ip:8080/api/v1/pods&quot;</code>查看存储的pod对象。</li>
<li>为<code>/api</code>下的资源注册路由，并绑定处理方法，以便对外提供RESTful API。调用链为”InstallLegacyAPI-&gt;InstallLegacyAPIGroup-&gt;installAPIResources-&gt;InstallREST-&gt;APIInstaller.Install”，逻辑与<code>APIExtensionsServer</code>注册路由的逻辑一致。</li>
<li>将routes添加到services中，然后将service添加到container中，对外提供服务。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controlplane/instance.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Instance)</span> <span class="title">InstallLegacyAPI</span><span class="params">(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为LegacyAPI中的资源定义RESTStorage，包括对Pod的资源存储类型</span></span><br><span class="line">	legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error building core storage: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	controllerName := <span class="string">&quot;bootstrap-controller&quot;</span></span><br><span class="line">	<span class="comment">// 声明一个RESTClient</span></span><br><span class="line">	coreClient := corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line">	<span class="comment">// 初始化bootstrap-controller，Controller是核心引导Kubernetes控制器循环的控制器管理器，它管理创建“Kubernetes”服务、“default”、“kube-system”和“kube-public”名称空间，并提供对服务IP的IP修复检查</span></span><br><span class="line">	bootstrapController := c.NewBootstrapController(legacyRESTStorage, coreClient, coreClient, coreClient, coreClient.RESTClient())</span><br><span class="line">	m.GenericAPIServer.AddPostStartHookOrDie(controllerName, bootstrapController.PostStartHook)</span><br><span class="line">	m.GenericAPIServer.AddPreShutdownHookOrDie(controllerName, bootstrapController.PreShutdownHook)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install &#x27;/api&#x27;下的路由</span></span><br><span class="line">	<span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error in registering group versions: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NewLegacyRESTStorage"><a href="#NewLegacyRESTStorage" class="headerlink" title="NewLegacyRESTStorage"></a>NewLegacyRESTStorage</h5>为核心组定义apiGroupInfo，并对组内的资源及其子资源创建restStorage，然后放到<code>restStorageMap</code>中。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k8s.io/kubernetes/pkg/registry/core/rest/storage_core.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c LegacyRESTStorageProvider)</span> <span class="title">NewLegacyRESTStorage</span><span class="params">(restOptionsGetter generic.RESTOptionsGetter)</span> <span class="params">(LegacyRESTStorage, genericapiserver.APIGroupInfo, error)</span></span> &#123;</span><br><span class="line">	apiGroupInfo := genericapiserver.APIGroupInfo&#123;</span><br><span class="line">		PrioritizedVersions:          legacyscheme.Scheme.PrioritizedVersionsForGroup(<span class="string">&quot;&quot;</span>),</span><br><span class="line">		VersionedResourcesStorageMap: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;&#125;,</span><br><span class="line">		Scheme:                       legacyscheme.Scheme,</span><br><span class="line">		ParameterCodec:               legacyscheme.ParameterCodec,</span><br><span class="line">		NegotiatedSerializer:         legacyscheme.Codecs,</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	podTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)</span><br><span class="line">	...</span><br><span class="line">	eventStorage, err := eventstore.NewREST(restOptionsGetter, <span class="keyword">uint64</span>(c.EventTTL.Seconds()))</span><br><span class="line">	...</span><br><span class="line">	limitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)</span><br><span class="line">	...</span><br><span class="line">	namespaceStorage, namespaceStatusStorage, namespaceFinalizeStorage, err := namespacestore.NewREST(restOptionsGetter)</span><br><span class="line">	...</span><br><span class="line">	podStorage, err := podstore.NewStorage(restOptionsGetter,nodeStorage.KubeletConnectionInfo,c.ProxyTransport,podDisruptionClient)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	restStorageMap := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;</span><br><span class="line">		<span class="string">&quot;pods&quot;</span>:             podStorage.Pod,</span><br><span class="line">		<span class="string">&quot;pods/attach&quot;</span>:      podStorage.Attach,</span><br><span class="line">		<span class="string">&quot;pods/status&quot;</span>:      podStorage.Status,</span><br><span class="line">		<span class="string">&quot;pods/log&quot;</span>:         podStorage.Log,</span><br><span class="line">		<span class="string">&quot;pods/exec&quot;</span>:        podStorage.Exec,</span><br><span class="line">		<span class="string">&quot;pods/portforward&quot;</span>: podStorage.PortForward,</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 将核心组的version设置为v1</span></span><br><span class="line">	apiGroupInfo.VersionedResourcesStorageMap[<span class="string">&quot;v1&quot;</span>] = restStorageMap</span><br><span class="line">	<span class="keyword">return</span> restStorage, apiGroupInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="InstallLegacyAPIGroup"><a href="#InstallLegacyAPIGroup" class="headerlink" title="InstallLegacyAPIGroup"></a>InstallLegacyAPIGroup</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apiserver/pkg/server/genericapiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">InstallLegacyAPIGroup</span><span class="params">(apiPrefix <span class="keyword">string</span>, apiGroupInfo *APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !s.legacyAPIGroupPrefixes.Has(apiPrefix) &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%q is not in the allowed legacy API prefixes: %v&quot;</span>, apiPrefix, s.legacyAPIGroupPrefixes.List())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从apiGroupInfos中取出前缀为`api`的apiGroupInfo，通过utilopenapi.ToProtoModels，将其格式化为OpenAPI</span></span><br><span class="line">	openAPIModels, err := s.getOpenAPIModels(apiPrefix, apiGroupInfo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to get openapi models: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将REST (存储、监视、代理和重定向)注册到restful Container中</span></span><br><span class="line">	<span class="keyword">if</span> err := s.installAPIResources(apiPrefix, apiGroupInfo, openAPIModels); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	s.Handler.GoRestfulContainer.Add(discovery.NewLegacyRootAPIHandler(s.discoveryAddresses, s.Serializer, apiPrefix).WebService())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InstallAPIs"><a href="#InstallAPIs" class="headerlink" title="InstallAPIs"></a>InstallAPIs</h4>对每个apiGroupsInfo，调用<code>InstallAPIGroups</code>，对<code>/apis</code>下的<code>APIGroup</code>进行暴露。通过<code>installAPIResources</code>为每个<code>resource</code>注册<code>path</code>、<code>storage</code>、<code>handler</code>，并将其注册到<code>route</code>、<code>webservice</code>中。这部分处理流程与<code>installAPIResources</code>部分的流程一致。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/server/genericapiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">InstallAPIGroups</span><span class="params">(apiGroupInfos ...*APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//空Group或空Version返回错误处理</span></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 从apiGroupInfos中取出&quot;/apis&quot;前缀的APIGroupInfo，通过utilopenapi.ToProtoModels，将其格式化为OpenAPI</span></span><br><span class="line">	openAPIModels, err := s.getOpenAPIModels(APIGroupPrefix, apiGroupInfos...)</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">for</span> _, apiGroupInfo := <span class="keyword">range</span> apiGroupInfos &#123;</span><br><span class="line">		<span class="comment">// 调用installAPIResources</span></span><br><span class="line">		<span class="keyword">if</span> err := s.installAPIResources(APIGroupPrefix, apiGroupInfo, openAPIModels); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to install api resources: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置discovery</span></span><br><span class="line">		apiVersionsForDiscovery := []metav1.GroupVersionForDiscovery&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.PrioritizedVersions &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			apiVersionsForDiscovery = <span class="built_in">append</span>(apiVersionsForDiscovery, metav1.GroupVersionForDiscovery&#123;</span><br><span class="line">				GroupVersion: groupVersion.String(),</span><br><span class="line">				Version:      groupVersion.Version,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		preferredVersionForDiscovery := metav1.GroupVersionForDiscovery&#123;</span><br><span class="line">			GroupVersion: apiGroupInfo.PrioritizedVersions[<span class="number">0</span>].String(),</span><br><span class="line">			Version:      apiGroupInfo.PrioritizedVersions[<span class="number">0</span>].Version,</span><br><span class="line">		&#125;</span><br><span class="line">		apiGroup := metav1.APIGroup&#123;</span><br><span class="line">			Name:             apiGroupInfo.PrioritizedVersions[<span class="number">0</span>].Group,</span><br><span class="line">			Versions:         apiVersionsForDiscovery,</span><br><span class="line">			PreferredVersion: preferredVersionForDiscovery,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s.DiscoveryGroupManager.AddGroup(apiGroup)</span><br><span class="line">		s.Handler.GoRestfulContainer.Add(discovery.NewAPIGroupHandler(s.Serializer, apiGroup).WebService())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建AggregatorServer"><a href="#创建AggregatorServer" class="headerlink" title="创建AggregatorServer"></a>创建AggregatorServer</h3><h4 id="逻辑概述-2"><a href="#逻辑概述-2" class="headerlink" title="逻辑概述"></a>逻辑概述</h4></li>
<li>创建<code>aggregatorServer</code>实例。</li>
<li>创建<code>apiregistrationClient</code>实例，实质为RESTClient</li>
<li>创建<code>crdRegistrationController</code>，它通过<code>AutoAPIServiceRegistration</code>来自动注册APIServices。aggregatorServer在启动时，会Run起5个goroutine，不断的对workequeue进行消费。在调用<code>checkService()</code>的时候，会把服务器的资源与cache上的做对比，然后根据比较结果，通过<code>apiRegistrationClient</code>对<code>apiService</code>进行操作。</li>
<li>通过<code>apiServicesToRegister</code>将apiService放入到队列中等待消费</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-apiserver/app/aggregator.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAggregatorServer</span><span class="params">(aggregatorConfig *aggregatorapiserver.Config, delegateAPIServer genericapiserver.DelegationTarget, apiExtensionInformers apiextensionsinformers.SharedInformerFactory)</span> <span class="params">(*aggregatorapiserver.APIAggregator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建aggregatorServer</span></span><br><span class="line">	aggregatorServer, err := aggregatorConfig.Complete().NewWithDelegate(delegateAPIServer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据LoopbackClientConfig配置创建apiRegistrationClient，</span></span><br><span class="line">	<span class="comment">// 这是一个RESTClient,REST是最基础的客户端。其对HTTP Request进行了封装，实现了RESTful风格的API。</span></span><br><span class="line">	<span class="comment">// 这个client用于与集群通信</span></span><br><span class="line">	apiRegistrationClient, err := apiregistrationclient.NewForConfig(aggregatorConfig.GenericConfig.LoopbackClientConfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建autoRegistrationController，用于将CRD对应的APIService自动注册到apiserver中</span></span><br><span class="line">	autoRegistrationController := autoregister.NewAutoRegisterController(aggregatorServer.APIRegistrationInformers.Apiregistration().V1().APIServices(), apiRegistrationClient)</span><br><span class="line">	<span class="comment">// 将每个apiService放入autoRegistrationController的sync队列中，在controller启动时，对apiServices进行添加</span></span><br><span class="line">	apiServices := apiServicesToRegister(delegateAPIServer, autoRegistrationController)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建crdRegistrationController，crdRegistrationController用autoRegistrationController注册CRD GroupVersions，这样它们就会自动保持同步</span></span><br><span class="line">	crdRegistrationController := crdregistration.NewCRDRegistrationController(</span><br><span class="line">		apiExtensionInformers.Apiextensions().V1().CustomResourceDefinitions(),</span><br><span class="line">		autoRegistrationController)</span><br><span class="line"></span><br><span class="line">	err = aggregatorServer.GenericAPIServer.AddPostStartHook(<span class="string">&quot;kube-apiserver-autoregistration&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">go</span> crdRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> aggregatorConfig.GenericConfig.MergedResourceConfig.AnyVersionForGroupEnabled(<span class="string">&quot;apiextensions.k8s.io&quot;</span>) &#123;</span><br><span class="line">				crdRegistrationController.WaitForInitialSync()</span><br><span class="line">			&#125;</span><br><span class="line">			autoRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = aggregatorServer.GenericAPIServer.AddBootSequenceHealthChecks(</span><br><span class="line">		makeAPIServiceAvailableHealthCheck(</span><br><span class="line">			<span class="string">&quot;autoregister-completion&quot;</span>,</span><br><span class="line">			apiServices,</span><br><span class="line">			aggregatorServer.APIRegistrationInformers.Apiregistration().V1().APIServices(),</span><br><span class="line">		),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实例化aggregatorServer"><a href="#实例化aggregatorServer" class="headerlink" title="实例化aggregatorServer"></a>实例化aggregatorServer</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kube-aggregator/pkg/apiserver/apiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">NewWithDelegate</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*APIAggregator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用aggregatorServer自己的OpenAPI handler</span></span><br><span class="line">	<span class="comment">// 将默认的genericServer配置OpenAPI handler置为空</span></span><br><span class="line">	openAPIConfig := c.GenericConfig.OpenAPIConfig</span><br><span class="line">	c.GenericConfig.OpenAPIConfig = <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 创建kube-aggregator，此处逻辑与kube-apiserver和apiextensions-apiserver相同</span></span><br><span class="line">	genericServer, err := c.GenericConfig.New(<span class="string">&quot;kube-aggregator&quot;</span>, delegationTarget)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建一个apiregistrationClient，实质为一组RestClient</span></span><br><span class="line">	<span class="comment">// 用于与group为&#x27;apiregistration.k8s&#x27;的资源进行交互。</span></span><br><span class="line">	apiregistrationClient, err := clientset.NewForConfig(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// informerFactory用于创建Informer</span></span><br><span class="line">	informerFactory := informers.NewSharedInformerFactory(</span><br><span class="line">		apiregistrationClient,</span><br><span class="line">		<span class="number">5</span>*time.Minute, </span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	s := &amp;APIAggregator&#123;</span><br><span class="line">		GenericAPIServer:           genericServer,</span><br><span class="line">		delegateHandler:            delegationTarget.UnprotectedHandler(),</span><br><span class="line">		proxyTransport:             c.ExtraConfig.ProxyTransport,</span><br><span class="line">		proxyHandlers:              <span class="keyword">map</span>[<span class="keyword">string</span>]*proxyHandler&#123;&#125;,</span><br><span class="line">		handledGroups:              sets.String&#123;&#125;,</span><br><span class="line">		lister:                     informerFactory.Apiregistration().V1().APIServices().Lister(),</span><br><span class="line">		APIRegistrationInformers:   informerFactory,</span><br><span class="line">		serviceResolver:            c.ExtraConfig.ServiceResolver,</span><br><span class="line">		openAPIConfig:              openAPIConfig,</span><br><span class="line">		egressSelector:             c.GenericConfig.EgressSelector,</span><br><span class="line">		proxyCurrentCertKeyContent: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(bytes []<span class="keyword">byte</span>, bytes2 []<span class="keyword">byte</span>)</span></span> &#123; <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span> &#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个apiGroupInfo，其groupName为&quot;apiregistration.k8s.io&quot;，封装资源信息及访问存储的RESTStorage</span></span><br><span class="line">	apiGroupInfo := apiservicerest.NewRESTStorage(c.GenericConfig.MergedResourceConfig, c.GenericConfig.RESTOptionsGetter)</span><br><span class="line">	<span class="comment">// 调用InstallAPIGroups，对APIService进行暴露</span></span><br><span class="line">	<span class="keyword">if</span> err := s.GenericAPIServer.InstallAPIGroup(&amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enabledVersions := sets.NewString()</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> apiGroupInfo.VersionedResourcesStorageMap &#123;</span><br><span class="line">		enabledVersions.Insert(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !enabledVersions.Has(v1.SchemeGroupVersion.Version) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;API group/version %s must be enabled&quot;</span>, v1.SchemeGroupVersion.String())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	apisHandler := &amp;apisHandler&#123;</span><br><span class="line">		codecs:         aggregatorscheme.Codecs,</span><br><span class="line">		lister:         s.lister,</span><br><span class="line">		discoveryGroup: discoveryGroup(enabledVersions),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 绑定过滤器</span></span><br><span class="line">	s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(<span class="string">&quot;/apis&quot;</span>, apisHandler)</span><br><span class="line">	s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandle(<span class="string">&quot;/apis/&quot;</span>, apisHandler)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实例化APIServiceRegistrationController，用来添加删除APIService</span></span><br><span class="line">	apiserviceRegistrationController := NewAPIServiceRegistrationController(informerFactory.Apiregistration().V1().APIServices(), s)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(c.ExtraConfig.ProxyClientCertFile) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(c.ExtraConfig.ProxyClientKeyFile) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		aggregatorProxyCerts, err := dynamiccertificates.NewDynamicServingContentFromFiles(<span class="string">&quot;aggregator-proxy-cert&quot;</span>, c.ExtraConfig.ProxyClientCertFile, c.ExtraConfig.ProxyClientKeyFile)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := aggregatorProxyCerts.RunOnce(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		aggregatorProxyCerts.AddListener(apiserviceRegistrationController)</span><br><span class="line">		s.proxyCurrentCertKeyContent = aggregatorProxyCerts.CurrentCertKeyContent</span><br><span class="line"></span><br><span class="line">		s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;aggregator-reload-proxy-client-cert&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">go</span> aggregatorProxyCerts.Run(<span class="number">1</span>, context.StopCh)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建AvailableConditionController，处理检查已注册API服务的可用性。</span></span><br><span class="line">	availableController, err := statuscontrollers.NewAvailableConditionController(</span><br><span class="line">		informerFactory.Apiregistration().V1().APIServices(),</span><br><span class="line">		c.GenericConfig.SharedInformerFactory.Core().V1().Services(),</span><br><span class="line">		c.GenericConfig.SharedInformerFactory.Core().V1().Endpoints(),</span><br><span class="line">		apiregistrationClient.ApiregistrationV1(),</span><br><span class="line">		c.ExtraConfig.ProxyTransport,</span><br><span class="line">		(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">byte</span>)</span>)<span class="params">(s.proxyCurrentCertKeyContent)</span>,</span></span><br><span class="line">		s.serviceResolver,</span><br><span class="line">		c.GenericConfig.EgressSelector,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将informer、resgistrationController、和用于可用性检测的apiServiceStatusAvailableController添加到PostStartHook中</span></span><br><span class="line">	s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;start-kube-aggregator-informers&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		informerFactory.Start(context.StopCh)</span><br><span class="line">		c.GenericConfig.SharedInformerFactory.Start(context.StopCh)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;apiservice-registration-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		handlerSyncedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">go</span> apiserviceRegistrationController.Run(context.StopCh, handlerSyncedCh)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-context.StopCh:</span><br><span class="line">		<span class="keyword">case</span> &lt;-handlerSyncedCh:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;apiservice-status-available-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// if we end up blocking for long periods of time, we may need to increase threadiness.</span></span><br><span class="line">		<span class="keyword">go</span> availableController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(genericfeatures.StorageVersionAPI) &amp;&amp;</span><br><span class="line">		utilfeature.DefaultFeatureGate.Enabled(genericfeatures.APIServerIdentity) &#123;</span><br><span class="line">		<span class="comment">// 在AggregatorServer中开启一个goroutine用来更新资源的storage version</span></span><br><span class="line">		s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;built-in-resources-storage-version-updater&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(hookContext genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			kubeClient, err := kubernetes.NewForConfig(hookContext.LoopbackClientConfig)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := wait.PollImmediateUntil(<span class="number">100</span>*time.Millisecond, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">				_, err := kubeClient.CoordinationV1().Leases(metav1.NamespaceSystem).Get(</span><br><span class="line">					context.TODO(), s.GenericAPIServer.APIServerID, metav1.GetOptions&#123;&#125;)</span><br><span class="line">				<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">			&#125;, hookContext.StopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to wait for apiserver-identity lease %s to be created: %v&quot;</span>,</span><br><span class="line">					s.GenericAPIServer.APIServerID, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 正常情况，一个apiserver只在启动时更新一次storage version</span></span><br><span class="line">			<span class="comment">// storage version可能会被不同的代理修改或删除，每10分钟进行一次一致性的update操作</span></span><br><span class="line">			<span class="comment">// 如果没发生改变，这个一致性的update操作不会进行循环，并且被apiserver阻塞住</span></span><br><span class="line">			<span class="keyword">go</span> wait.PollImmediateUntil(<span class="number">10</span>*time.Minute, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">				<span class="comment">/** 所有apiserver (aggregator-apiserver, kube-apiserver</span></span><br><span class="line"><span class="comment">				 *  apiextensions-apiserver)共享相同的generic apiserver配置。</span></span><br><span class="line"><span class="comment">				 *  当generic apiserver安装api时，使用相同的StorageVersion管理器注册所有内置资源。</span></span><br><span class="line"><span class="comment">				 **/</span></span><br><span class="line">				s.GenericAPIServer.StorageVersionManager.UpdateStorageVersions(</span><br><span class="line">					 hookContext.LoopbackClientConfig, s.GenericAPIServer.APIServerID)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">			&#125;, hookContext.StopCh)</span><br><span class="line">			<span class="comment">// StorageVersionManager完成第一轮更新时，PostStartHook会返回unblock/healthz。</span></span><br><span class="line">			<span class="comment">// 处理程序不再阻塞write请求</span></span><br><span class="line">			wait.PollImmediateUntil(<span class="number">1</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> s.GenericAPIServer.StorageVersionManager.Completed(), <span class="literal">nil</span></span><br><span class="line">			&#125;, hookContext.StopCh)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="kube-aggregator的clientset"><a href="#kube-aggregator的clientset" class="headerlink" title="kube-aggregator的clientset"></a>kube-aggregator的clientset</h6><p>Clientset根据为一个group中资源的不同Version，为其设置不同的restClient</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/clientset.go</span></span><br><span class="line"><span class="keyword">type</span> Clientset <span class="keyword">struct</span> &#123;</span><br><span class="line">	*discovery.DiscoveryClient</span><br><span class="line">	apiregistrationV1beta1 *apiregistrationv1beta1.ApiregistrationV1beta1Client</span><br><span class="line">	apiregistrationV1      *apiregistrationv1.ApiregistrationV1Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建autoRegistrationController"><a href="#创建autoRegistrationController" class="headerlink" title="创建autoRegistrationController"></a>创建autoRegistrationController</h5><ul>
<li>apiServiceInformer提供对APIServices共享的informer和list的访问。</li>
<li>apiServiceClient是一个ClientSet，ClientSet封装了对Resource和Version的管理方法。每一个Resource和Version都以函数的方式暴露给开发者。<br>autoRegisterController负责将CRD(CustomResourceDefinition)对应的APIServices自动注册到apiserver上。其内部有一个queue，在启动时的时候，goroutine不断的对queue进行消费。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kube-aggregator/pkg/controllers/autoregister/autoregister_controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAutoRegisterController</span><span class="params">(apiServiceInformer informers.APIServiceInformer, apiServiceClient apiregistrationclient.APIServicesGetter)</span> *<span class="title">autoRegisterController</span></span> &#123;</span><br><span class="line">	<span class="comment">// 实例化autoRegisterController	</span></span><br><span class="line">	c := &amp;autoRegisterController&#123;</span><br><span class="line">		apiServiceLister:  apiServiceInformer.Lister(),</span><br><span class="line">		apiServiceSynced:  apiServiceInformer.Informer().HasSynced,</span><br><span class="line">		apiServiceClient:  apiServiceClient,</span><br><span class="line">		apiServicesToSync: <span class="keyword">map</span>[<span class="keyword">string</span>]*v1.APIService&#123;&#125;,</span><br><span class="line"></span><br><span class="line">		apiServicesAtStart: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125;,</span><br><span class="line"></span><br><span class="line">		syncedSuccessfullyLock: &amp;sync.RWMutex&#123;&#125;,</span><br><span class="line">		syncedSuccessfully:     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125;,</span><br><span class="line">		<span class="comment">// delaying_queue</span></span><br><span class="line">		queue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">&quot;autoregister&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对比服务器etcd和cache中的资源</span></span><br><span class="line">	c.syncHandler = c.checkAPIService</span><br><span class="line"></span><br><span class="line">	apiServiceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			cast := obj.(*v1.APIService)</span><br><span class="line">			c.queue.Add(cast.Name)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(_, obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			cast := obj.(*v1.APIService)</span><br><span class="line">			c.queue.Add(cast.Name)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			cast, ok := obj.(*v1.APIService)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Couldn&#x27;t get object from tombstone %#v&quot;</span>, obj)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				cast, ok = tombstone.Obj.(*v1.APIService)</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Tombstone contained unexpected object: %#v&quot;</span>, obj)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			c.queue.Add(cast.Name)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="syncHandler-checkAPIService"><a href="#syncHandler-checkAPIService" class="headerlink" title="syncHandler(checkAPIService)"></a>syncHandler(checkAPIService)</h6><p>checkAPIService根据所需APIService对象列表同步当前APIService。<br>|  | A. desired: not found | B. desired: sync on start  |  C. desired: sync always |<br>| — | — | — | — |<br>| 1. current: lookup error   | error  | error   | error |<br>| 2. current: not found   | -   | create once   | create |<br>| 3. current: no sync  | -   | - | - |<br>| 4. current: sync on start, not present at start | -  | - | - |<br>| 5. current: sync on start, present at start  | delete once  | update once   | update once |<br>| 6. current: sync always | delete | update once   | update |</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kube-aggregator/pkg/controllers/autoregister/autoregister_controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *autoRegisterController)</span> <span class="title">checkAPIService</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从cacheStorage中获取apiService</span></span><br><span class="line">	desired := c.GetAPIServiceToSync(name)</span><br><span class="line">	curr, err := c.apiServiceLister.Get(name)</span><br><span class="line">	<span class="comment">// if we&#x27;ve never synced this service successfully, record a successful sync.</span></span><br><span class="line">	hasSynced := c.hasSyncedSuccessfully(name)</span><br><span class="line">	<span class="keyword">if</span> !hasSynced &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				c.setSyncedSuccessfully(name)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="comment">// we had a real error, just return it (1A,1B,1C)</span></span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span> &amp;&amp; !apierrors.IsNotFound(err):</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we don&#x27;t have an entry and we don&#x27;t want one (2A)</span></span><br><span class="line">	<span class="keyword">case</span> apierrors.IsNotFound(err) &amp;&amp; desired == <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// the local object only wants to sync on start and has already synced (2B,5B,6B &quot;once&quot; enforcement)</span></span><br><span class="line">	<span class="keyword">case</span> isAutomanagedOnStart(desired) &amp;&amp; hasSynced:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// we don&#x27;t have an entry and we do want one (2B,2C)</span></span><br><span class="line">	<span class="keyword">case</span> apierrors.IsNotFound(err) &amp;&amp; desired != <span class="literal">nil</span>:</span><br><span class="line">		_, err := c.apiServiceClient.APIServices().Create(context.TODO(), desired, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> apierrors.IsAlreadyExists(err) &#123;</span><br><span class="line">			<span class="comment">// created in the meantime, we&#x27;ll get called again</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we aren&#x27;t trying to manage this APIService (3A,3B,3C)</span></span><br><span class="line">	<span class="keyword">case</span> !isAutomanaged(curr):</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// the remote object only wants to sync on start, but was added after we started (4A,4B,4C)</span></span><br><span class="line">	<span class="keyword">case</span> isAutomanagedOnStart(curr) &amp;&amp; !c.apiServicesAtStart[name]:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// the remote object only wants to sync on start and has already synced (5A,5B,5C &quot;once&quot; enforcement)</span></span><br><span class="line">	<span class="keyword">case</span> isAutomanagedOnStart(curr) &amp;&amp; hasSynced:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// we have a spurious APIService that we&#x27;re managing, delete it (5A,6A)</span></span><br><span class="line">	<span class="keyword">case</span> desired == <span class="literal">nil</span>:</span><br><span class="line">		opts := metav1.DeleteOptions&#123;Preconditions: metav1.NewUIDPreconditions(<span class="keyword">string</span>(curr.UID))&#125;</span><br><span class="line">		err := c.apiServiceClient.APIServices().Delete(context.TODO(), curr.Name, opts)</span><br><span class="line">		<span class="keyword">if</span> apierrors.IsNotFound(err) || apierrors.IsConflict(err) &#123;</span><br><span class="line">			<span class="comment">// deleted or changed in the meantime, we&#x27;ll get called again</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if the specs already match, nothing for us to do</span></span><br><span class="line">	<span class="keyword">case</span> reflect.DeepEqual(curr.Spec, desired.Spec):</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we have an entry and we have a desired, now we deconflict.  Only a few fields matter. (5B,5C,6B,6C)</span></span><br><span class="line">	apiService := curr.DeepCopy()</span><br><span class="line">	apiService.Spec = desired.Spec</span><br><span class="line">	_, err = c.apiServiceClient.APIServices().Update(context.TODO(), apiService, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) || apierrors.IsConflict(err) &#123;</span><br><span class="line">		<span class="comment">// deleted or changed in the meantime, we&#x27;ll get called again</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建CRDRegistrationController"><a href="#创建CRDRegistrationController" class="headerlink" title="创建CRDRegistrationController"></a>创建CRDRegistrationController</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pkg/controlplane/controller/crdregistration/crdregistration_controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCRDRegistrationController</span><span class="params">(crdinformer crdinformers.CustomResourceDefinitionInformer, apiServiceRegistration AutoAPIServiceRegistration)</span> *<span class="title">crdRegistrationController</span></span> &#123;</span><br><span class="line">	c := &amp;crdRegistrationController&#123;</span><br><span class="line">		crdLister:              crdinformer.Lister(),</span><br><span class="line">		crdSynced:              crdinformer.Informer().HasSynced,</span><br><span class="line">		apiServiceRegistration: apiServiceRegistration,</span><br><span class="line">		syncedInitialSet:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		queue:                  workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">&quot;crd_autoregistration_controller&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	c.syncHandler = c.handleVersionUpdate</span><br><span class="line">	crdinformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			cast := obj.(*apiextensionsv1.CustomResourceDefinition)</span><br><span class="line">			c.enqueueCRD(cast)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			<span class="comment">// Enqueue both old and new object to make sure we remove and add appropriate API services.</span></span><br><span class="line">			<span class="comment">// The working queue will resolve any duplicates and only changes will stay in the queue.</span></span><br><span class="line">			c.enqueueCRD(oldObj.(*apiextensionsv1.CustomResourceDefinition))</span><br><span class="line">			c.enqueueCRD(newObj.(*apiextensionsv1.CustomResourceDefinition))</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			cast, ok := obj.(*apiextensionsv1.CustomResourceDefinition)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Couldn&#x27;t get object from tombstone %#v&quot;</span>, obj)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				cast, ok = tombstone.Obj.(*apiextensionsv1.CustomResourceDefinition)</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;Tombstone contained unexpected object: %#v&quot;</span>, obj)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			c.enqueueCRD(cast)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备启动"><a href="#准备启动" class="headerlink" title="准备启动"></a>准备启动</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *APIAggregator)</span> <span class="title">PrepareRun</span><span class="params">()</span> <span class="params">(preparedAPIAggregator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// add post start hook before generic PrepareRun in order to be before /healthz installation</span></span><br><span class="line">	<span class="keyword">if</span> s.openAPIConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">&quot;apiservice-openapi-controller&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">go</span> s.openAPIAggregationController.Run(context.StopCh)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prepared := s.GenericAPIServer.PrepareRun()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delay OpenAPI setup until the delegate had a chance to setup their OpenAPI handlers</span></span><br><span class="line">	<span class="keyword">if</span> s.openAPIConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">		specDownloader := openapiaggregator.NewDownloader()</span><br><span class="line">		openAPIAggregator, err := openapiaggregator.BuildAndRegisterAggregator(</span><br><span class="line">			&amp;specDownloader,</span><br><span class="line">			s.GenericAPIServer.NextDelegate(),</span><br><span class="line">			s.GenericAPIServer.Handler.GoRestfulContainer.RegisteredWebServices(),</span><br><span class="line">			s.openAPIConfig,</span><br><span class="line">			s.GenericAPIServer.Handler.NonGoRestfulMux)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> preparedAPIAggregator&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		s.openAPIAggregationController = openapicontroller.NewAggregationController(&amp;specDownloader, openAPIAggregator)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个server和一个channel</span></span><br><span class="line">	<span class="keyword">return</span> preparedAPIAggregator&#123;APIAggregator: s, runnable: prepared&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//k8s.io/apiserver/pkg/server/genericapiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">PrepareRun</span><span class="params">()</span> <span class="title">preparedGenericAPIServer</span></span> &#123;</span><br><span class="line">	s.delegationTarget.PrepareRun()</span><br><span class="line">	<span class="comment">// 创建Swagger服务</span></span><br><span class="line">	<span class="keyword">if</span> s.openAPIConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.OpenAPIVersionedService, s.StaticOpenAPISpec = routes.OpenAPI&#123;</span><br><span class="line">			Config: s.openAPIConfig,</span><br><span class="line">		&#125;.Install(s.Handler.GoRestfulContainer, s.Handler.NonGoRestfulMux)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用InstallPathHandler注册&quot;/healthz&quot;和&quot;/livez&quot;健康检查，并绑定相应的handler</span></span><br><span class="line">	s.installHealthz()</span><br><span class="line">	s.installLivez()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加&quot;/readyz&quot;健康检查</span></span><br><span class="line">	err := s.addReadyzShutdownCheck(s.readinessStopCh)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Failed to install readyz shutdown check %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s.installReadyz()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register audit backend preShutdownHook.</span></span><br><span class="line">	<span class="keyword">if</span> s.AuditBackend != <span class="literal">nil</span> &#123;</span><br><span class="line">		err := s.AddPreShutdownHook(<span class="string">&quot;audit-backend&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			s.AuditBackend.Shutdown()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">&quot;Failed to add pre-shutdown hook for audit-backend %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> preparedGenericAPIServer&#123;s&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>cobra执行启动server最后调用server.Run，最后会去执行<code>genericServer.Run</code>。这个server只在<code>stopCh</code>接收到信号时，才会退出。Run方法中调用了NonBlockingRun，创建一个https的server，对配置的addr(–insecure-bind-address和–insecure-port)绑定一个listener进行监听</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//k8s.io/apiserver/pkg/server/genericapiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	delayedStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(delayedStopCh)</span><br><span class="line"></span><br><span class="line">		&lt;-stopCh</span><br><span class="line"></span><br><span class="line">		<span class="comment">// As soon as shutdown is initiated, /readyz should start returning failure.</span></span><br><span class="line">		<span class="comment">// This gives the load balancer a window defined by ShutdownDelayDuration to detect that /readyz is red</span></span><br><span class="line">		<span class="comment">// and stop sending traffic to this server.</span></span><br><span class="line">		<span class="built_in">close</span>(s.readinessStopCh)</span><br><span class="line"></span><br><span class="line">		time.Sleep(s.ShutdownDelayDuration)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// close socket after delayed stopCh</span></span><br><span class="line">	stoppedCh, err := s.NonBlockingRun(delayedStopCh)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-stopCh</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run shutdown hooks directly. This includes deregistering from the kubernetes endpoint in case of kube-apiserver.</span></span><br><span class="line">	err = s.RunPreShutdownHooks()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for the delayed stopCh before closing the handler chain (it rejects everything after Wait has been called).</span></span><br><span class="line">	&lt;-delayedStopCh</span><br><span class="line">	<span class="comment">// wait for stoppedCh that is closed when the graceful termination (server.Shutdown) is finished.</span></span><br><span class="line">	&lt;-stoppedCh</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for all requests to finish, which are bounded by the RequestTimeout variable.</span></span><br><span class="line">	s.HandlerChainWaitGroup.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="s-NonBlockingRun"><a href="#s-NonBlockingRun" class="headerlink" title="s.NonBlockingRun"></a>s.NonBlockingRun</h3><p>NonBlockingRun主要执行步骤：</p>
<ol>
<li>创建并启动审计日志服务</li>
<li>创建并启动https server</li>
<li>遍历PostStartHooks，并为每个PostStartHook开一个goroutine执行PostStartHookFunc<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k8s.io/apiserver/pkg/server/genericapiserver.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">NonBlockingRun</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建审计的stop channel，用来在httpserver关闭后，不丢弃审计事件</span></span><br><span class="line">	auditStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动审计的channel</span></span><br><span class="line">	<span class="keyword">if</span> s.AuditBackend != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := s.AuditBackend.Run(auditStopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to run the audit backend: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建httpsServer</span></span><br><span class="line">	internalStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> stoppedCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> s.SecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.Handler != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		stoppedCh, err = s.SecureServingInfo.Serve(s.Handler, s.ShutdownTimeout, internalStopCh)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">close</span>(internalStopCh)</span><br><span class="line">			<span class="built_in">close</span>(auditStopCh)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now that listener have bound successfully, it is the</span></span><br><span class="line">	<span class="comment">// responsibility of the caller to close the provided channel to</span></span><br><span class="line">	<span class="comment">// ensure cleanup.</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		<span class="built_in">close</span>(internalStopCh)</span><br><span class="line">		<span class="keyword">if</span> stoppedCh != <span class="literal">nil</span> &#123;</span><br><span class="line">			&lt;-stoppedCh</span><br><span class="line">		&#125;</span><br><span class="line">		s.HandlerChainWaitGroup.Wait()</span><br><span class="line">		<span class="built_in">close</span>(auditStopCh)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 执行postStartHooks</span></span><br><span class="line">	s.RunPostStartHooks(stopCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送ready信号</span></span><br><span class="line">	<span class="keyword">if</span> _, err := systemd.SdNotify(<span class="literal">true</span>, <span class="string">&quot;READY=1\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Unable to send systemd daemon successful start message: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stoppedCh, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>kube-apiserver都做了些啥</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>容器健康检查-探针机制</title>
    <url>/2021/08/27/Kubernetes/K8S/%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5-%E6%8E%A2%E9%92%88%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h1><p>k8s提供了三种探针，确保容器在部署后处于运行状态，这三种探针分别是：<strong>就绪检测探针(readinessProbe)</strong> 、 <strong>存活检测探针(livenessProbe)</strong> 、 <strong>启动检测探针(startupProbe)</strong> 。</p>
<ul>
<li>livenessProbe用于检测容器是否处于健康状态，如果不健康，就<strong>删除重建</strong>。</li>
<li>readinessProbe用于检测启动时，容器状态是否就绪，当容器状态就绪，才开始接收请求流量，否则会从对应的Endpoint列表中被剔除。</li>
<li>startupProbe容器启动时执行，如果配置了startupProbe，就会在容器启动后再去执行livenessProbe和readinessProbe，避免容器内的应用程序在启动前就被杀掉。startupProbe检测成功后，就不会再进行检测。</li>
</ul>
<p>任何一种探针，都存在着3种状态：Success、Failure、Unknown，只有Success表示检测成功。其状态定义为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/results/results_manager.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Unknown Result = <span class="literal">iota</span> - <span class="number">1</span></span><br><span class="line">  Success</span><br><span class="line">  Failure</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> r &#123;</span><br><span class="line">  <span class="keyword">case</span> Success:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span></span><br><span class="line">  <span class="keyword">case</span> Failure:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Failure&quot;</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>k8s为每一种探针都提供了三种检测机制：</p>
<ul>
<li>HTTP GET Action：对容器的IP地址，指定端口和路径，执行HTTP GET请求。如果探测器收到响应，并且响应状态码不代表错误（状态码2xx或3xx），则认为检测成功。如果没收到响应，或返回错误状态码，则认为检测失败。</li>
<li>TCP Socket Action：尝试与容器指定的端口建立TCP连接，如果连接成功，则认为检测成功，反之检测失败</li>
<li>Exec Action：在容器内执行自定义的命令，并检查命令的退出状态码。如果状态码为0，则检测成功。其他所有状态码都会被认为失败。exec执行的指令，会占用容器内的资源，所以指令应当简单、轻量。</li>
</ul>
<p>每种探针都有通用的可配置字段：</p>
<ul>
<li>initialDelaySeconds：探测延迟时长，即容器启动多久后再开始第一次探测操作，显示为delay属性，默认为0秒</li>
<li>periodSeconds：探测的频度，默认为10秒，最小值为1秒。过高的频率会对Pod对象带来较大的额外开销，过低的频率有会使得对错误的反应不及时。</li>
<li>successThreshold：处于失败状态时，探测操作至少连续多少次成功才被认为是检测通过，默认值为1，最小值也为1</li>
<li>failureThreshold：处于成功状态时，探测操作至少连续多少次的失败才被视为检测不通过，默认值为3，最小值为1</li>
<li>timeoutSeconds：探测的超时时长，默认为1秒，最小是也为1秒</li>
</ul>
<h2 id="就绪探针-readinessProbe"><a href="#就绪探针-readinessProbe" class="headerlink" title="就绪探针(readinessProbe)"></a>就绪探针(readinessProbe)</h2><p>定义就绪探针意味着，Pod在启动阶段不接收任何数据，并且仅在探测成功时，才开始接收数据。</p>
<p>在Pod的整个生命周期中，就绪探针都会进行就绪探测，并确定Pod是否可以接收客户端请求，当容器就绪探针返回success时，表示容器已准备好接收请求。如果容器未通过<code>readinessProbe</code>检测，它不会被终止或重新启动，而是通知其尚未就绪，端点控制器(Endpoints Controller)会将该IP从所有匹配到此Pod的Serivce对象的Endpoint列表中删除。</p>
<p>就绪探针的状态值默认为Failure。<strong>如果容器未定义就绪探针，则容器默认状态为Success。</strong></p>
<p><img src="/2021/08/27/Kubernetes/K8S/%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5-%E6%8E%A2%E9%92%88%E6%9C%BA%E5%88%B6/readinessProbe.jpg"></p>
<h2 id="存活探针-livenessProbe"><a href="#存活探针-livenessProbe" class="headerlink" title="存活探针(livenessProbe)"></a>存活探针(livenessProbe)</h2><p>检查容器是否还在运行。可以为pod中的每个容器单独指定存活探针。如果探测失败，k8s将定期执行探针并重新启动容器。<strong>如果容器未定义存活探针，则容器默认状态为Success。</strong></p>
<h2 id="启动探针-startupProbe"><a href="#启动探针-startupProbe" class="headerlink" title="启动探针(startupProbe)"></a>启动探针(startupProbe)</h2><p>启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉。也可以延长readinessProbe和livenessProbe的initialDelaySeconds来解决。</p>
<p>启动探针启动时执行，如果定义了启动探针，那么在启动探针探测成功之前，其他探针都不会进行探测。如果启动探针探测失败，kubelet会杀死容器，容器将按照<code>Restart Policy</code>进行重启。如果没有定义startupProbe，那么默认为<code>Success</code></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>省略的Pod的yaml文件中其他配置，仅保留了spec.containers.livenessProbe相关</p>
<h3 id="exec探针"><a href="#exec探针" class="headerlink" title="exec探针"></a>exec探针</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot; touch /tmp/healthy;sleep 60; rm -rf /tmp/healthy; sleep 600&quot;</span>]</span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;test&quot;</span>,<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;/tmp/healthy&quot;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="tcpSocket探针"><a href="#tcpSocket探针" class="headerlink" title="tcpSocket探针"></a>tcpSocket探针</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="httpGet探针"><a href="#httpGet探针" class="headerlink" title="httpGet探针"></a>httpGet探针</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/ping</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="探针的创建与工作，源码解析"><a href="#探针的创建与工作，源码解析" class="headerlink" title="探针的创建与工作，源码解析"></a>探针的创建与工作，源码解析</h2><p>相关代码基于kubernetes1.20.4</p>
<h3 id="创建probeManager对象，管理探针和探针检测结果"><a href="#创建probeManager对象，管理探针和探针检测结果" class="headerlink" title="创建probeManager对象，管理探针和探针检测结果"></a>创建probeManager对象，管理探针和探针检测结果</h3><ol>
<li><p>在启动kubelet时，kubelet会创建probeManager对象，同时开启一个循环syncLoop()，同步Pod状态。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">klet.probeManager = prober.NewManager(</span><br><span class="line">    klet.statusManager,</span><br><span class="line">    klet.livenessManager,</span><br><span class="line">    klet.startupManager,</span><br><span class="line">    klet.runner,</span><br><span class="line">    kubeDeps.Recorder)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewManager创建了管理pod的各种探针的Manager</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  statusManager status.Manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  livenessManager results.Manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  startupManager results.Manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  runner kubecontainer.CommandRunner,</span></span></span><br><span class="line"><span class="params"><span class="function">  recorder record.EventRecorder)</span> <span class="title">Manager</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  prober := newProber(runner, recorder)</span><br><span class="line">  readinessManager := results.NewManager()</span><br><span class="line">  <span class="keyword">return</span> &amp;manager&#123;</span><br><span class="line">    statusManager:    statusManager,</span><br><span class="line">    prober:           prober,</span><br><span class="line">    readinessManager: readinessManager,</span><br><span class="line">    livenessManager:  livenessManager,</span><br><span class="line">    startupManager:   startupManager,</span><br><span class="line">    workers:          <span class="built_in">make</span>(<span class="keyword">map</span>[probeKey]*worker),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> results.Manager是一个管理器，里面用hashmap存放着容器探针的检测结果。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// guards the cache</span></span><br><span class="line">  sync.RWMutex</span><br><span class="line">  <span class="comment">// map of container ID -&gt; probe Result</span></span><br><span class="line">  cache <span class="keyword">map</span>[kubecontainer.ContainerID]Result</span><br><span class="line">  <span class="comment">// channel of updates</span></span><br><span class="line">  updates <span class="keyword">chan</span> Update</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> kubelet的syncLoop()中监听着Pod创建事件，当创建Pod的时候，会把Pod的信息交给probeManager处理</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kubelet.go中的syncLoop()调用的syncLoopIteration方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">  syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">      klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (ADD, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">      handler.HandlePodAdditions(u.Pods)</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kubelet.go中的HandlePodAdditions()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodAdditions</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">    existingPods := kl.podManager.GetPods()</span><br><span class="line">    kl.podManager.AddPod(pod)</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建探针</span></span><br><span class="line">    kl.probeManager.AddPod(pod)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据Container的Probe相关属性创建Worker"><a href="#根据Container的Probe相关属性创建Worker" class="headerlink" title="根据Container的Probe相关属性创建Worker"></a>根据Container的Probe相关属性创建Worker</h3></li>
<li><p>创建Pod的时候，遍历Pod中的容器，判断容器是否添加了StartupProbe、ReadinessProbe、LivenessProbe，如果添加了，就会为这个探针创建一个Worker对象。这个Worker在一个goroutine中进行检测工作。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/prober_manager.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">AddPod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 读写锁</span></span><br><span class="line">  m.workerLock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.workerLock.Unlock()</span><br><span class="line"></span><br><span class="line">  key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line">  <span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">    key.containerName = c.Name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.StartupProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">      key.probeType = startup</span><br><span class="line">      <span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;Startup probe already exists! %v - %v&quot;</span>,</span><br><span class="line">          format.Pod(pod), c.Name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      w := newWorker(m, startup, pod, c)</span><br><span class="line">      m.workers[key] = w</span><br><span class="line">      <span class="keyword">go</span> w.run()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.ReadinessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">      key.probeType = readiness</span><br><span class="line">      <span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;Readiness probe already exists! %v - %v&quot;</span>,</span><br><span class="line">          format.Pod(pod), c.Name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      w := newWorker(m, readiness, pod, c)</span><br><span class="line">      m.workers[key] = w</span><br><span class="line">      <span class="keyword">go</span> w.run()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.LivenessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">      key.probeType = liveness</span><br><span class="line">      <span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;Liveness probe already exists! %v - %v&quot;</span>,</span><br><span class="line">          format.Pod(pod), c.Name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      w := newWorker(m, liveness, pod, c)</span><br><span class="line">      m.workers[key] = w</span><br><span class="line">      <span class="keyword">go</span> w.run()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="每个探针的Worker是什么"><a href="#每个探针的Worker是什么" class="headerlink" title="每个探针的Worker是什么"></a>每个探针的Worker是什么</h3></li>
<li><p>newWorker操作会创建一个probe worker，worker定义。初始化worker时，会为其赋值pod、container的相关信息。并根据探针类型，初始化其默认状态：<code>readinessProbe</code>的默认值是<code>Failure</code>，<code>livenessProbe</code>的默认值是<code>Success</code>，<code>startupProbe</code>的初始值是<code>UNKNOWN</code></p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/worker.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWorker</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  m *manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  probeType probeType,</span></span></span><br><span class="line"><span class="params"><span class="function">  pod *v1.Pod,</span></span></span><br><span class="line"><span class="params"><span class="function">  container v1.Container)</span> *<span class="title">worker</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  w := &amp;worker&#123;</span><br><span class="line">    stopCh:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>), <span class="comment">// Buffer so stop() can be non-blocking.</span></span><br><span class="line">    pod:          pod,</span><br><span class="line">    container:    container,</span><br><span class="line">    probeType:    probeType,</span><br><span class="line">    probeManager: m,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> probeType &#123;</span><br><span class="line">  <span class="keyword">case</span> readiness:</span><br><span class="line">    w.spec = container.ReadinessProbe</span><br><span class="line">    w.resultsManager = m.readinessManager</span><br><span class="line">    w.initialValue = results.Failure</span><br><span class="line">  <span class="keyword">case</span> liveness:</span><br><span class="line">    w.spec = container.LivenessProbe</span><br><span class="line">    w.resultsManager = m.livenessManager</span><br><span class="line">    w.initialValue = results.Success</span><br><span class="line">  <span class="keyword">case</span> startup:</span><br><span class="line">    w.spec = container.StartupProbe</span><br><span class="line">    w.resultsManager = m.startupManager</span><br><span class="line">    w.initialValue = results.Unknown</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  basicMetricLabels := metrics.Labels&#123;</span><br><span class="line">    <span class="string">&quot;probe_type&quot;</span>: w.probeType.String(),</span><br><span class="line">    <span class="string">&quot;container&quot;</span>:  w.container.Name,</span><br><span class="line">    <span class="string">&quot;pod&quot;</span>:        w.pod.Name,</span><br><span class="line">    <span class="string">&quot;namespace&quot;</span>:  w.pod.Namespace,</span><br><span class="line">    <span class="string">&quot;pod_uid&quot;</span>:    <span class="keyword">string</span>(w.pod.UID),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prometheus收集时需要的数据格式</span></span><br><span class="line">  w.proberResultsSuccessfulMetricLabels = deepCopyPrometheusLabels(basicMetricLabels)</span><br><span class="line">  w.proberResultsSuccessfulMetricLabels[<span class="string">&quot;result&quot;</span>] = probeResultSuccessful</span><br><span class="line"></span><br><span class="line">  w.proberResultsFailedMetricLabels = deepCopyPrometheusLabels(basicMetricLabels)</span><br><span class="line">  w.proberResultsFailedMetricLabels[<span class="string">&quot;result&quot;</span>] = probeResultFailed</span><br><span class="line"></span><br><span class="line">  w.proberResultsUnknownMetricLabels = deepCopyPrometheusLabels(basicMetricLabels)</span><br><span class="line">  w.proberResultsUnknownMetricLabels[<span class="string">&quot;result&quot;</span>] = probeResultUnknown</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="comment">// 用于停止probe，newWorker()时默认为make(chan struct&#123;&#125;,1)</span></span><br><span class="line">  stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 只读</span></span><br><span class="line">  pod *v1.Pod</span><br><span class="line">  <span class="comment">// 只读</span></span><br><span class="line">  container v1.Container</span><br><span class="line"></span><br><span class="line">  spec *v1.Probe</span><br><span class="line">  probeType probeType</span><br><span class="line">  initialValue results.Result</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于存放探测结果</span></span><br><span class="line">  resultsManager results.Manager</span><br><span class="line">  probeManager   *manager</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当前worker最近一次探测的容器id</span></span><br><span class="line">  containerID kubecontainer.ContainerID</span><br><span class="line">  <span class="comment">// 最近一次探测结果</span></span><br><span class="line">  lastResult results.Result</span><br><span class="line">  <span class="comment">// 探测结果相同的次数</span></span><br><span class="line">  resultRun <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否跳过探测</span></span><br><span class="line">  onHold <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 探测结果标签</span></span><br><span class="line">  proberResultsSuccessfulMetricLabels metrics.Labels</span><br><span class="line">  proberResultsFailedMetricLabels     metrics.Labels</span><br><span class="line">  proberResultsUnknownMetricLabels    metrics.Labels</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="worker的具体工作内容"><a href="#worker的具体工作内容" class="headerlink" title="worker的具体工作内容"></a>worker的具体工作内容</h3><ol start="4">
<li>worker.run()中，根据Container定义的探针，获取周期，然后根据时间间隔，循环执行doProbe() <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  probeTickerPeriod := time.Duration(w.spec.PeriodSeconds) * time.Second</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If kubelet restarted the probes could be started in rapid succession.</span></span><br><span class="line">  <span class="comment">// Let the worker wait for a random portion of tickerPeriod before probing.</span></span><br><span class="line">  time.Sleep(time.Duration(rand.Float64() * <span class="keyword">float64</span>(probeTickerPeriod)))</span><br><span class="line"></span><br><span class="line">  probeTicker := time.NewTicker(probeTickerPeriod)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Clean up.</span></span><br><span class="line">    probeTicker.Stop()</span><br><span class="line">    <span class="keyword">if</span> !w.containerID.IsEmpty() &#123;</span><br><span class="line">      w.resultsManager.Remove(w.containerID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.probeManager.removeWorker(w.pod.UID, w.container.Name, w.probeType)</span><br><span class="line">    ProberResults.Delete(w.proberResultsSuccessfulMetricLabels)</span><br><span class="line">    ProberResults.Delete(w.proberResultsFailedMetricLabels)</span><br><span class="line">    ProberResults.Delete(w.proberResultsUnknownMetricLabels)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">probeLoop:</span><br><span class="line">  <span class="keyword">for</span> w.doProbe() &#123;</span><br><span class="line">    <span class="comment">// Wait for next probe tick.</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-w.stopCh:</span><br><span class="line">      <span class="keyword">break</span> probeLoop</span><br><span class="line">    <span class="keyword">case</span> &lt;-probeTicker.C:</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h3><ol start="5">
<li><p>doProbe()方法，对container进行一次探测，然后向Manager记录探测结果，并根据执行结果判断是否还需要继续探测。即从kubelet的Manager来获取Pod的状态。<br>kubelet的Manager通过ClientSet获取Pod对象，用来保证Pod的最新的status，它会把Pod的status信息同步更新到apiserver。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">doProbe</span><span class="params">()</span> <span class="params">(keepGoing <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">recover</span>() &#125;() <span class="comment">// 发生panic，捕获后不处理，直接吞掉</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">defer</span> runtime.HandleCrash(<span class="function"><span class="keyword">func</span><span class="params">(_ <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123; keepGoing = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从kubelet的Manager获取Pod的status</span></span><br><span class="line">  status, ok := w.probeManager.statusManager.GetPodStatus(w.pod.UID)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// Pod还没有被创建，或者已经被删除</span></span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;No status for pod: %v&quot;</span>, format.Pod(w.pod))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pod如果已经终止了，就不再需要Worker了</span></span><br><span class="line">  <span class="keyword">if</span> status.Phase == v1.PodFailed || status.Phase == v1.PodSucceeded &#123;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Pod %v %v, exiting probe worker&quot;</span>,</span><br><span class="line">      format.Pod(w.pod), status.Phase)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从hashmap里获取Pod对象中的Container状态，</span></span><br><span class="line">  c, ok := podutil.GetContainerStatus(status.ContainerStatuses, w.container.Name)</span><br><span class="line">  <span class="keyword">if</span> !ok || <span class="built_in">len</span>(c.ContainerID) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Either the container has not been created yet, or it was deleted.</span></span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Probe target container not found: %v - %v&quot;</span>,</span><br><span class="line">      format.Pod(w.pod), w.container.Name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// Wait for more information.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// container发生变化时，将新的container存放到resultsManager里</span></span><br><span class="line">  <span class="keyword">if</span> w.containerID.String() != c.ContainerID &#123;</span><br><span class="line">    <span class="keyword">if</span> !w.containerID.IsEmpty() &#123;</span><br><span class="line">      w.resultsManager.Remove(w.containerID)</span><br><span class="line">    &#125;</span><br><span class="line">    w.containerID = kubecontainer.ParseContainerID(c.ContainerID)</span><br><span class="line">    w.resultsManager.Set(w.containerID, w.initialValue, w.pod)</span><br><span class="line">    <span class="comment">// We&#x27;ve got a new container; resume probing.</span></span><br><span class="line">    w.onHold = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> w.onHold &#123;</span><br><span class="line">    <span class="comment">// Worker is on hold until there is a new container.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取不到container状态是，将结果设置为Failure</span></span><br><span class="line">  <span class="keyword">if</span> c.State.Running == <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Non-running container probed: %v - %v&quot;</span>,</span><br><span class="line">      format.Pod(w.pod), w.container.Name)</span><br><span class="line">    <span class="keyword">if</span> !w.containerID.IsEmpty() &#123;</span><br><span class="line">      w.resultsManager.Set(w.containerID, results.Failure, w.pod)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Abort if the container will not be restarted.</span></span><br><span class="line">    <span class="keyword">return</span> c.State.Terminated == <span class="literal">nil</span> ||</span><br><span class="line">      w.pod.Spec.RestartPolicy != v1.RestartPolicyNever</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动时间小于设置探针的延迟探测时间，则Worker继续下一次探测</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">int32</span>(time.Since(c.State.Running.StartedAt.Time).Seconds()) &lt; w.spec.InitialDelaySeconds &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果容器的没有启动起来，那么只有startupProbe才会进行探测，其他的probe worker，就一直在循环等待。</span></span><br><span class="line">  <span class="comment">// 如果容器已经started，那么startupProbe，就直接返回true,不用再执行probe()探测了</span></span><br><span class="line">  <span class="keyword">if</span> c.Started != <span class="literal">nil</span> &amp;&amp; *c.Started &#123;</span><br><span class="line">    <span class="keyword">if</span> w.probeType == startup &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> w.probeType != startup &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 探测容器，获取容器状态</span></span><br><span class="line">  result, err := w.probeManager.prober.probe(w.probeType, w.pod, status, w.container, w.containerID)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Prober error, throw away the result.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Metric状态收集</span></span><br><span class="line">  <span class="keyword">switch</span> result &#123;</span><br><span class="line">  <span class="keyword">case</span> results.Success:</span><br><span class="line">    ProberResults.With(w.proberResultsSuccessfulMetricLabels).Inc()</span><br><span class="line">  <span class="keyword">case</span> results.Failure:</span><br><span class="line">    ProberResults.With(w.proberResultsFailedMetricLabels).Inc()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    ProberResults.With(w.proberResultsUnknownMetricLabels).Inc()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> w.lastResult == result &#123;</span><br><span class="line">    w.resultRun++</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    w.lastResult = result</span><br><span class="line">    w.resultRun = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == results.Failure &amp;&amp; w.resultRun &lt; <span class="keyword">int</span>(w.spec.FailureThreshold)) ||</span><br><span class="line">    (result == results.Success &amp;&amp; w.resultRun &lt; <span class="keyword">int</span>(w.spec.SuccessThreshold)) &#123;</span><br><span class="line">    <span class="comment">// Success or failure is below threshold - leave the probe state unchanged.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录探测结果</span></span><br><span class="line">  w.resultsManager.Set(w.containerID, result, w.pod)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w.probeType == liveness || w.probeType == startup) &amp;&amp; result == results.Failure &#123;</span><br><span class="line">    <span class="comment">// 容器存活检查失败或者启动检查失败时，需要重新启动容器。停止探测，直到获取了新的containerId。</span></span><br><span class="line">    w.onHold = <span class="literal">true</span></span><br><span class="line">    w.resultRun = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="根据探针类型进行相应操作处理"><a href="#根据探针类型进行相应操作处理" class="headerlink" title="根据探针类型进行相应操作处理"></a>根据探针类型进行相应操作处理</h3><ol start="6">
<li>w.probeManager.prober.probe(w.probeType, w.pod, status, w.container, w.containerID)，会调用到runProbe()，根据probeType，进行具体处理。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">runProbe</span><span class="params">(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  timeout := time.Duration(p.TimeoutSeconds) * time.Second</span><br><span class="line">  <span class="keyword">if</span> p.Exec != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Exec-Probe Pod: %v, Container: %v, Command: %v&quot;</span>, pod.Name, container.Name, p.Exec.Command)</span><br><span class="line">    command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)</span><br><span class="line">    <span class="keyword">return</span> pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> p.HTTPGet != <span class="literal">nil</span> &#123;</span><br><span class="line">    scheme := strings.ToLower(<span class="keyword">string</span>(p.HTTPGet.Scheme))</span><br><span class="line">    host := p.HTTPGet.Host</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      host = status.PodIP</span><br><span class="line">    &#125;</span><br><span class="line">    port, err := extractPort(p.HTTPGet.Port, container)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> probe.Unknown, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    path := p.HTTPGet.Path</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;HTTP-Probe Host: %v://%v, Port: %v, Path: %v&quot;</span>, scheme, host, port, path)</span><br><span class="line">    url := formatURL(scheme, host, port, path)</span><br><span class="line">    headers := buildHeader(p.HTTPGet.HTTPHeaders)</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;HTTP-Probe Headers: %v&quot;</span>, headers)</span><br><span class="line">    <span class="keyword">switch</span> probeType &#123;</span><br><span class="line">    <span class="keyword">case</span> liveness:</span><br><span class="line">      <span class="keyword">return</span> pb.livenessHTTP.Probe(url, headers, timeout)</span><br><span class="line">    <span class="keyword">case</span> startup:</span><br><span class="line">      <span class="keyword">return</span> pb.startupHTTP.Probe(url, headers, timeout)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> pb.readinessHTTP.Probe(url, headers, timeout)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> p.TCPSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">    port, err := extractPort(p.TCPSocket.Port, container)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> probe.Unknown, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    host := p.TCPSocket.Host</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      host = status.PodIP</span><br><span class="line">    &#125;</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;TCP-Probe Host: %v, Port: %v, Timeout: %v&quot;</span>, host, port, timeout)</span><br><span class="line">    <span class="keyword">return</span> pb.tcp.Probe(host, port, timeout)</span><br><span class="line">  &#125;</span><br><span class="line">  klog.Warningf(<span class="string">&quot;Failed to find probe builder for container: %v&quot;</span>, container)</span><br><span class="line">  <span class="keyword">return</span> probe.Unknown, <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;missing probe handler for %s:%s&quot;</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="具体操作执行方法"><a href="#具体操作执行方法" class="headerlink" title="具体操作执行方法"></a>具体操作执行方法</h3><ol start="7">
<li>根据probeType，会执行对应的execProber.Probe()、httpProber.Probe()、tcpProber.Probe()。相应方法定义在<code>pkg/probe</code></li>
</ol>
<ul>
<li>如果是exec，那么就会解析exec.command，然后<code>k8s.io/utils/exec</code>的ioutil执行命令，判断exited的值是否为0，如果为0则返回<code>probe.Success</code>，否则返回<code>probe.Failure</code>，如果执行命令发生超时，则返回<code>probe.Unknown</code> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pr execProber)</span> <span class="title">Probe</span><span class="params">(e exec.Cmd)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  writer := ioutils.LimitWriter(&amp;dataBuffer, maxReadLength)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果是HTTPGet，那么会发送一个Http的get请求，如果发生error，就返回<code>probe.Failure</code>。通过http状态码进行健康检测，如果StatusCode为<code>2xx</code>，就返回<code>probe.Success</code>，如果为<code>3xx</code>就返回<code>probe.Warning</code>。<code>probe.Warning</code>的意思是，逻辑上是成功了，但是会附带一些额外的调试信息。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoHTTPProbe</span><span class="params">(url *url.URL, headers http.Header, client GetHTTPInterface)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url.String(), <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> probe.Failure, err.Error(), <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对Header的一系列处理</span></span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过GetHTTPInterface发送Request</span></span><br><span class="line">  res, err := client.Do(req)</span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  b, err := utilio.ReadAtMost(res.Body, maxRespBodyLength)</span><br><span class="line">  <span class="comment">// 获取http状态码，20</span></span><br><span class="line">  body := <span class="keyword">string</span>(b)</span><br><span class="line">  <span class="keyword">if</span> res.StatusCode &gt;= http.StatusOK &amp;&amp; res.StatusCode &lt; http.StatusBadRequest &#123;</span><br><span class="line">    <span class="keyword">if</span> res.StatusCode &gt;= http.StatusMultipleChoices &#123; <span class="comment">// Redirect</span></span><br><span class="line">      klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Probe terminated redirects for %s, Response: %v&quot;</span>, url.String(), *res)</span><br><span class="line">      <span class="keyword">return</span> probe.Warning, body, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Probe succeeded for %s, Response: %v&quot;</span>, url.String(), *res)</span><br><span class="line">    <span class="keyword">return</span> probe.Success, body, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">&quot;HTTP probe failed with statuscode: %d&quot;</span>, res.StatusCode), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>如果是TCPSocket，则通过<code>主机+端口号</code>，检测是否可以建立TCP Socket，如果可以就返回Success，如果不可以，就返回Failure。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pr tcpProber)</span> <span class="title">Probe</span><span class="params">(host <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 拼接主机+端口号</span></span><br><span class="line">  <span class="keyword">return</span> DoTCPProbe(net.JoinHostPort(host, strconv.Itoa(port)), timeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoTCPProbe检查到该地址的TCP Socket是否可以打开</span></span><br><span class="line"><span class="comment">// TCP Socket可以打开返回Success，反之返回Failure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoTCPProbe</span><span class="params">(addr <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  conn, err := net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, addr, timeout)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> probe.Failure, err.Error(), <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  err = conn.Close()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">&quot;Unexpected error closing TCP probe socket: %v (%#v)&quot;</span>, err, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> probe.Success, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="停止探针"><a href="#停止探针" class="headerlink" title="停止探针"></a>停止探针</h3><ol>
<li>删除Pod。kubelet启动时，在syncLoop()时，监听着channel中发来的事件，如果是删除事件<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pkg/kubelet/kubelet.go </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">        klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;SyncLoop (REMOVE, %q): %q&quot;</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">        handler.HandlePodRemoves(u.Pods)</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>调用manager.RemovePod()，该方法中会遍历pod中的container，然后通过worker.stop()停止doProbe()的循环调用。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">RemovePod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	m.workerLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> m.workerLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">		key.containerName = c.Name</span><br><span class="line">		<span class="keyword">for</span> _, probeType := <span class="keyword">range</span> [...]probeType&#123;readiness, liveness, startup&#125; &#123;</span><br><span class="line">			key.probeType = probeType</span><br><span class="line">			<span class="keyword">if</span> worker, ok := m.workers[key]; ok &#123;</span><br><span class="line">				worker.stop()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
worker.stop()通过向worker的channel发送数据，通知其停止探针：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> w.stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// Non-blocking.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Pod</tag>
        <tag>Container</tag>
      </tags>
  </entry>
  <entry>
    <title>存储之NFS</title>
    <url>/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>NFS(Network FileSystem)，可以通过网络，让不同的机器、不同的操作系统可以分享文件。可以看作是一个文件服务器(File Server)。</p>
<p>NFS服务器可以将源成的NFS服务器分享的目录，挂载到客户端的机器中。当服务器端将系统目录分享出来后。其他客户端就可以将这个目录挂载到自己系统上的挂载点上。</p>
<p><img src="/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/nfs_server_client.png"></p>
<p>NFS使用网络进行数据的传输，NFS服务端与客户端之间通过RPC。服务器在启动时，会随机取用数个端口，并主动向RPC注册。因此RPC可以知道每个端口的功能。客户端上，RPC固定使用111端口，来监听客户端的请求，并响应给客户端对应服务正确的端口。</p>
<p><img src="/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/nfs_rpc.png"></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="安装配置NFS"><a href="#安装配置NFS" class="headerlink" title="安装配置NFS"></a>安装配置NFS</h2><ol>
<li>安装NFS<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install nfs-utils rpcbind -y</span><br></pre></td></tr></table></figure></li>
<li>创建共享目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/exports</span><br><span class="line"></span><br><span class="line">/usr/nfs  10.0.38.0/24(rw,no_root_squash,sync)</span><br><span class="line"></span><br><span class="line"># exportfs -r</span><br></pre></td></tr></table></figure></li>
</ol>
<p>exports文件说明：<br>内容格式应为： <code>&lt;输出目录&gt; [客户端](参数...) [客户端2](参数...)</code></p>
<p>说明：</p>
<ul>
<li>输出目录：本地需要共享给客户端的文件夹路径</li>
<li>客户端：<ul>
<li>可以指定ip，如10.0.38.82</li>
<li>可以指定子网，如10.0.38.0/24</li>
<li>可以指定主机名</li>
<li>可以指定域中的所有主机，如*.[域名]</li>
<li>指定所有主机： *</li>
</ul>
</li>
<li>可选参数之间用逗号分隔<table>
<thead>
<tr>
<th>参数值</th>
<th>内容说明</th>
</tr>
</thead>
<tbody><tr>
<td>rw<br>ro</td>
<td>该目录分享的权限是可读写(read-write)或只读(read-only)，但最终能不能读写，还是与文件系统的rwx及身份有关</td>
</tr>
<tr>
<td>sync<br>async</td>
<td>sync代表数据会同步写入到内存与硬盘中。async代表数据会先暂存于内存当中，而非直接写入硬盘</td>
</tr>
<tr>
<td>no_root_squash<br>root_squash</td>
<td>客户端使用NFS文件系统的账号若为root时，系统该如何判断这个账号的身份？预设的情况下，客户端root的身份会由root_squash的设定压缩成nfsnobody，如此对服务器的系统会交由保障。但如果想要开放客户端使用root身份来操作服务器的文件系统，那么就需要开no_root_squash才行</td>
</tr>
<tr>
<td>all_squash</td>
<td>不论登入NFS的使用者是什么身份，他的身份都会被压缩为匿名用户(nobody(nfsnobody))</td>
</tr>
<tr>
<td>anonuid<br>anongid</td>
<td>anon指anonymous(匿名者)。关于*_squash提到的匿名用户的UID设定值，通常为nobody(nfsnobody)，但是可以自行设定这个UID的值。当然，这个UID必须要存在于你的/etc/passwd当中。anonuid指的是UID而anongid则是群组的GID</td>
</tr>
</tbody></table>
</li>
</ul>
<ol start="3">
<li>启动服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start rpcbind &amp;&amp; systemctl enable rpcbind</span><br><span class="line">systemctl start nfs &amp;&amp; systemctl enable nfs</span><br></pre></td></tr></table></figure>
通过showmount [-ae] [hostname|ip]查看共享目录</li>
</ol>
<ul>
<li>-a:显示目前主机与客户端的NFS联机分享的状态</li>
<li>-e:显示某主机的的/etc/exports所分享的目录数据</li>
</ul>
<p><img src="/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/nfs-show-mount.png"></p>
<h1 id="k8s使用nfs-client-provisioner，创建PV和PVC"><a href="#k8s使用nfs-client-provisioner，创建PV和PVC" class="headerlink" title="k8s使用nfs-client-provisioner，创建PV和PVC"></a>k8s使用nfs-client-provisioner，创建PV和PVC</h1><p>nfs-client-provisioner使用现有的和已配置的NFS服务器来支持通过持久卷声明动态配置 Kubernetes 持久卷。其本身不提供NFS，需要现有的NFS服务器提供存储。</p>
<ul>
<li>PV以<code>&#123;namespace&#125;-&#123;pvcName&#125;-&#123;pvName&#125;</code>的命名格式提供</li>
<li>PV回收时以<code>archieved-&#123;namespace&#125;-&#123;pvcName&#125;-&#123;pvName&#125;</code>的命名格式提供</li>
</ul>
<p>k8s部署nfs-client-provisioner的<a href="https://github.com/Owl0214/DevOps/tree/main/nfs">清单文件</a>：</p>
<ul>
<li>deployment需要修改NFS服务器地址，以及NFS共享路径</li>
<li>官方配置说明参见<a href="https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner">NFS Ganesha server and external provisioner</a></li>
</ul>
<h2 id="使用NFS创建PV和PVC说明"><a href="#使用NFS创建PV和PVC说明" class="headerlink" title="使用NFS创建PV和PVC说明"></a>使用NFS创建PV和PVC说明</h2><ul>
<li><p>k8s 创建PVC时，需指定<code>storageClassName</code>，其值与StorageClass中配置的name相同。</p>
</li>
<li><p>StorageClass中指定了<code>provisioner: fuseim.pri/ifs</code>。其中<code>fuseim.pri/ifs</code>与<code>PROVISIONER_NAME</code>相同</p>
</li>
<li><p>绑定PV如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">mountPath:</span> &#123;<span class="string">container-filepath</span>&#125;</span><br><span class="line">          <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">nfs:</span> </span><br><span class="line">                <span class="attr">server:</span> &#123;<span class="string">nfs-server-ip</span>&#125;</span><br><span class="line">                <span class="attr">path:</span> &#123;<span class="string">nfs-shared-filepath</span>&#125;    </span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li>
<li><p>绑定PVC如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">mountPath:</span> &#123;<span class="string">container-filepath</span>&#125;</span><br><span class="line">          <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">                <span class="attr">claimName:</span> &#123;<span class="string">myapp-pvc</span>&#125;            </span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;<span class="string">myapp-pvc</span>&#125;</span><br><span class="line">  <span class="attr">namespace:</span> &#123;<span class="string">namespace</span>&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> &#123;<span class="string">StorageClass</span>&#125; <span class="comment"># StorageClass中配置的name</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span> <span class="comment">#存储卷大小</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h1><p><a href="http://cn.linux.vbird.org/linux_server/0330nfs.php">鸟哥的Linux私房菜–NFS服务器</a><br><a href="https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner">NFS Ganesha server and external provisioner</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Storage</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>NFS</tag>
      </tags>
  </entry>
</search>
