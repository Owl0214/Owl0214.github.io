<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DevOps实战之部署GitLab</title>
    <url>/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2GitLab/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建Redis服务</li>
<li>搭建PostgreSQL服务</li>
<li>搭建Gitlab服务并配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3></li>
<li>postgres:13.2</li>
<li>redis:6.2.3</li>
<li>gitlab/gitlab-ce:13.11.4-ce.0</li>
</ul>
<p>镜像说明：因之前部署了sonarqube，使用了postgres，所以此处使用的镜像版本，与部署Sonar的相同，网上帖子中，普遍使用的gitlab、redis、postgresql均为samessrsbn的版本，我均选择了各组件的官方镜像。此处也可以复用sonar已经部署的postgres，而不用另外创建。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="官方部署方式"><a href="#官方部署方式" class="headerlink" title="官方部署方式"></a>官方部署方式</h3><p><a href="https://docs.gitlab.com/charts/">官方文档</a>推荐使用Helm安装部署，但会安装很多如Grafana、Prometheus等附加组件。</p>
<h3 id="自定义资源清单"><a href="#自定义资源清单" class="headerlink" title="自定义资源清单"></a>自定义资源清单</h3><p>只部署了postgres、redis和gitlab，其他组件，有需要时，可自定义清单文件进行配置。其中部署gitlab时，需要手动创建共享存储挂载卷目录<code>/usr/nfs/data/gitlab/data</code>、<code>/usr/nfs/data/gitlab/config</code>、<code>/usr/nfs/data/gitlab/log</code></p>
<p><a href="https://github.com/Owl0214/DevOps/tree/main/gitlab">gitlab资源清单</a></p>
<h3 id="配置LDAP"><a href="#配置LDAP" class="headerlink" title="配置LDAP"></a>配置LDAP</h3><p>修改配置文件gitlab.rb，容器内路径为/etc/gitlab，容器外为nfs对应目录。修改后，重启pod或在容器内执行<code>gitlab-ctl reconfigure</code>。此处提供两种配置方式，两种仅格式不同，第一种为<a href="https://docs.gitlab.com/13.11/ee/administration/auth/ldap/index.html">官方示例</a>格式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">gitlab_rails[&#x27;ldap_enabled&#x27;]</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">gitlab_rails[&#x27;prevent_ldap_sign_in&#x27;]</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="string">gitlab_rails[&#x27;ldap_servers&#x27;]</span> <span class="string">=</span> &#123;</span><br><span class="line"><span class="string">&#x27;main&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">  <span class="string">&#x27;label&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;LDAP&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;host&#x27;</span> <span class="string">=&gt;</span>  <span class="string">&#x27;10.0.38.82&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;port&#x27;</span> <span class="string">=&gt;</span> <span class="number">30423</span>,</span><br><span class="line">  <span class="string">&#x27;uid&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;encryption&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;plain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;verify_certificates&#x27;</span> <span class="string">=&gt;</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;bind_dn&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn=admin,dc=example,dc=org&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;password&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;verify_certificates&#x27;</span> <span class="string">=&gt;</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;tls_options&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">    <span class="string">&#x27;ca_file&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ssl_version&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ciphers&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cert&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;timeout&#x27;</span> <span class="string">=&gt;</span> <span class="number">10</span>,</span><br><span class="line">  <span class="string">&#x27;active_directory&#x27;</span> <span class="string">=&gt;</span> <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;allow_username_or_email_login&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&#x27;block_auto_created_users&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&#x27;base&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;dc=example,dc=com&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;user_filter&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span> <span class="string">=&gt;</span> [<span class="string">&#x27;uid&#x27;</span>, <span class="string">&#x27;userid&#x27;</span>, <span class="string">&#x27;sAMAccountName&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;email&#x27;</span> <span class="string">=&gt;</span> [<span class="string">&#x27;mail&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;userPrincipalName&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;first_name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;givenName&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;last_name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;sn&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;lowercase_usernames&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">  <span class="comment"># EE Only</span></span><br><span class="line">  <span class="string">&#x27;group_base&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;admin_group&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;external_groups&#x27;</span> <span class="string">=&gt;</span> [],</span><br><span class="line">  <span class="string">&#x27;sync_ssh_keys&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## LDAP Settings</span></span><br><span class="line"><span class="comment">##! Docs: https://docs.gitlab.com/omnibus/settings/ldap.html</span></span><br><span class="line"><span class="comment">##! **Be careful not to break the indentation in the ldap_servers block. It is</span></span><br><span class="line"><span class="comment">##!   in yaml format and the spaces must be retained. Using tabs will not work.**</span></span><br><span class="line"></span><br><span class="line"><span class="string">gitlab_rails[&#x27;ldap_enabled&#x27;]</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">gitlab_rails[&#x27;prevent_ldap_sign_in&#x27;]</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##! **remember to close this block with &#x27;EOS&#x27; below**</span></span><br><span class="line"><span class="string">gitlab_rails[&#x27;ldap_servers&#x27;]</span> <span class="string">=</span> <span class="string">YAML.load</span> <span class="string">&lt;&lt;-&#x27;EOS&#x27;</span></span><br><span class="line">  <span class="attr">main:</span> <span class="comment"># &#x27;main&#x27; is the GitLab &#x27;provider ID&#x27; of this LDAP server</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">&#x27;LDAP&#x27;</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">&#x27;10.0.38.82&#x27;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">30423</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">&#x27;cn&#x27;</span></span><br><span class="line">    <span class="attr">bind_dn:</span> <span class="string">&#x27;cn=admin,dc=example,dc=org&#x27;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    <span class="attr">encryption:</span> <span class="string">&#x27;plain&#x27;</span> <span class="comment"># &quot;start_tls&quot; or &quot;simple_tls&quot; or &quot;plain&quot;</span></span><br><span class="line">    <span class="attr">verify_certificates:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">smartcard_auth:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">active_directory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">allow_username_or_email_login:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">lowercase_usernames:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">block_auto_created_users:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">base:</span> <span class="string">&#x27;dc=example,dc=org&#x27;</span></span><br><span class="line">    <span class="attr">user_filter:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">## EE only</span></span><br><span class="line">    <span class="attr">group_base:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">admin_group:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">sync_ssh_keys:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">EOS</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>访问页面，认证窗口处，显示LDAP和Standard两种登录认证方式。</p>
<p><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2GitLab/login.png" alt="1"></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存淘汰算法-LRU</title>
    <url>/2021/06/09/Algorithm/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU/</url>
    <content><![CDATA[<h1 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h1><p>维护一个单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul>
</li>
</ol>
<p><img src="/2021/06/09/Algorithm/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU/LRU-single-linkedlist.jpg"></p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>无论访问的数据是否在链表中已存在，都需要遍历链表确认一遍。时间复杂度为O(n)</p>
<ol>
<li>如果节点在链表中存在。将其从原来位置删除和再插入到链表头部的时间复杂度均为O(1)。</li>
<li>如果节点在链表中不存在。链表未满时，直接做链表的插入操作，时间复杂度O(1)。链表满时，先删除链表尾结点，时间复杂度O(1)。再做插入操作，时间复杂度也是O(1)。</li>
</ol>
<p>均摊时间复杂度为O(n)</p>
<p>使用了除链表本身外的length和capacity来表示当前有多少个节点和一共有多少个节点，空间复杂度应为为O(1)</p>
<h1 id="链表-散列表法"><a href="#链表-散列表法" class="headerlink" title="链表+散列表法"></a>链表+散列表法</h1><p>维护一个双向链表和一个哈希表。</p>
<p>双向链表用来维护数据，并实现LRU算法。Hash表用来降低时间复杂度。</p>
<ol>
<li>如果节点在链表中不存在，则在链表中新增节点，并计算key的哈希值，将其放到hashmap中，hash表中存放该节点的指针。</li>
<li>如果节点存在，则在链表中，将其从原来的位置删除，再插入到链表头部。</li>
<li>淘汰时，删除链表尾结点，在链表头部插入新元素。</li>
</ol>
<p><img src="/2021/06/09/Algorithm/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU/LRU-hash-doublelinklist.png"></p>
<h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>查询时：</strong></p>
<p>如果数据量较小的话，理论上来说，如果n个数据平均散列到m个槽上，则每个槽上的链表长度为k=n/m。时间复杂度为O(k)。</p>
<p>如果数据量较大的话，均匀分布下，哈希表的查询复杂度为O(1)。链表平均分布的情况下，查询时间复杂度为O(k)。均摊后，时间复杂度为O(1)。</p>
<p><strong>插入和删除操作时：</strong></p>
<p>因为使用了哈希表，哈希表中存放了双向链表的节点地址，所以访问链表节点的时间复杂度由O(n)，降低到了O(1)。而双向链表的插入和删除操作的时间复杂度均为O(1)。所以均摊后，时间复杂度为O(1)</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://leetcode-cn.com/problems/lru-cache-lcci/">力扣 16.25. LRU 缓存</a><br><a href="https://time.geekbang.org/column/article/64858">GeekTime 数据结构与算法之美 - 20 | 散列表（下）</a><br><a href="https://time.geekbang.org/column/article/41013">GeekTime 数据结构与算法之美 - 6 | 链表（上）</a><br><a href="https://github.com/Owl0214/algorithm/tree/main/LRU">Demo传送门</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署Jenkins</title>
    <url>/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建Jenkins服务</li>
<li>配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3>jenkins/jenkins:lts-jdk11</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建NFS"><a href="#创建NFS" class="headerlink" title="创建NFS"></a>创建NFS</h3><h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/jenkins">jenkins资源清单</a></p>
<h3 id="启动Jenkins"><a href="#启动Jenkins" class="headerlink" title="启动Jenkins"></a>启动Jenkins</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/jenkins</span><br><span class="line">kubectl apply -f .</span><br></pre></td></tr></table></figure>

<h3 id="访问Web页面"><a href="#访问Web页面" class="headerlink" title="访问Web页面"></a>访问Web页面</h3><p>访问入口：http://[NodeIp]:30002/</p>
<p><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/first-visit.png"></p>
<p>初次访问时，需要使用initialAdminPassword中的字符串进行登录，由于配置了共享存储，可不用进入容器中查询，直接到相应的挂载目录下查找。</p>
<p><code>cat [共享存储路径]/secrets/initialAdminPassword</code></p>
<p>安装推荐插件，或自定义选择插件安装。<br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/install-tools.png"></p>
<h2 id="配置ldap登录"><a href="#配置ldap登录" class="headerlink" title="配置ldap登录"></a>配置ldap登录</h2><h3 id="创建LDAP组和用户"><a href="#创建LDAP组和用户" class="headerlink" title="创建LDAP组和用户"></a>创建LDAP组和用户</h3><ol>
<li>使用cn=admin,dc=example,dc=org登录LDAP</li>
<li>创建Posix Group，ldap</li>
<li>在Posix Group下创建User Account，admin</li>
</ol>
<h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><p>管理员登录jenkins后，进入<strong>Manage Jenkins</strong>，点击<strong>Security</strong>下的<strong>Configure Global Security</strong>。<br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/manage-jenkins.png"></p>
<p>在<strong>Configure Global Security</strong>页面下，配置安全域，选择LDAP方式。<br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/safe.png"></p>
<h4 id="配置详细信息"><a href="#配置详细信息" class="headerlink" title="配置详细信息"></a>配置详细信息</h4><ol>
<li>Server: LDAP服务器地址，使用ldap的Service名称+端口号<code>ldap://ldap-service:389</code>。因创建的ldap的Service类型是NodePort，也可以使用节点ip:port。</li>
<li>User search base: <code>dc=example,dc=org</code></li>
<li>User search filter: <code>uid=&#123;0&#125;</code></li>
<li>Group search base: <code>dc=example,dc=org</code></li>
<li>Manager DN: <code>cn=admin,dc=example,dc=org</code></li>
<li>Manager Password: <code>admin</code></li>
</ol>
<p><strong>配置完LDAP相关信息后，点击Test LDAP settings</strong><br><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Jenkins/test-success.png"></p>
<h4 id="配置LDAP后无法登录Jenkins问题"><a href="#配置LDAP后无法登录Jenkins问题" class="headerlink" title="配置LDAP后无法登录Jenkins问题"></a>配置LDAP后无法登录Jenkins问题</h4><p>由于配置不当导致Jenkins无法登录时，可以修改config.xml，去除ldap认证</p>
<ol>
<li>cd到NFS挂载的路径下，备份config.xml</li>
<li>在配置文件中找到</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">securityRealm</span> <span class="attr">class</span>=<span class="string">&quot;hudson.security.LDAPSecurityRealm&quot;</span> <span class="attr">plugin</span>=<span class="string">&quot;ldap@1.20&quot;</span>&gt;</span></span><br><span class="line">  ……</span><br><span class="line"><span class="tag">&lt;/<span class="name">securityRealm</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并将其修改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">securityRealm</span> <span class="attr">class</span>=<span class="string">&quot;hudson.security.HudsonPrivateSecurityRealm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">disableSignup</span>&gt;</span>false<span class="tag">&lt;/<span class="name">disableSignup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">enableCaptcha</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enableCaptcha</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">securityRealm</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署Nexus</title>
    <url>/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建Nexus服务</li>
<li>配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3>sonatype/nexus3:3.30.1</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/nexus">资源清单</a></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>因配置了Ingress，故需要在客户端host文件中，配置相应的域名解析如:win10下，修改C:\Windows\System32\drivers\etc\hosts文件，添加<code>xx.xx.xx.xx nexus.xxx.com</code>，该域名与Ingress中的配置相同。</p>
<p>浏览器访问<a href="http://nexus.xxx.com/">http://nexus.xxx.com</a> 即可访问nexu页面</p>
<h2 id="配置LDAP"><a href="#配置LDAP" class="headerlink" title="配置LDAP"></a>配置LDAP</h2><p><a href="https://help.sonatype.com/repomanager3/system-configuration/user-authentication/ldap">官网文档配置参照</a></p>
<h3 id="登录Nexus"><a href="#登录Nexus" class="headerlink" title="登录Nexus"></a>登录Nexus</h3><p>admin的初始化密码位于/nexus-data/admin.password，可在共享存储路径下查看admin.password文件。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/login.png"></p>
<p>初次登录页面时，会提示修改密码。然后开启匿名访问权限。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/AnonymousAccess.png"></p>
<h3 id="修改Configuration"><a href="#修改Configuration" class="headerlink" title="修改Configuration"></a>修改Configuration</h3><p>进入配置管理页面-&gt;Security-&gt;LDAP，点击Create connection</p>
<p><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/config.png"></p>
<h4 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h4><p>配置LDAP连接，点击Verify Connection。连接成功后提示Connection to LDAP server verified: ldap://xx.xx.xx.xx:xxxx</p>
<p><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/ldap-connection-config.png"></p>
<h4 id="用户、组过滤配置"><a href="#用户、组过滤配置" class="headerlink" title="用户、组过滤配置"></a>用户、组过滤配置</h4><p>配置完LDAP连接后，点击next配置用户和组。<br>在Configuration template的下拉框中，定义了配置的模板：</p>
<ul>
<li>Active Directory: </li>
<li>Generic Ldap Server:</li>
<li>Posix with Dynamic Groups:</li>
<li>Posix with Static Groups:</li>
</ul>
<p>配置用户组过滤条件后，点击Verify usermapping,会弹出用户列表。点击Verify Login，输入LDAP中的用户名密码，即可验证LDAP中的用户登录Nexus<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/user-group-config.png"></p>
<h2 id="角色配置"><a href="#角色配置" class="headerlink" title="角色配置"></a>角色配置</h2><p>Nexus创建的用户或LDAP的用户，需由管理员分配角色。</p>
<p>点击Security-&gt;Users，通过Source查看LDAP的用户列表。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/config-role.png"></p>
<p>双击用户列表中的用户，进入配置页面，选择相应的角色进行保存。<br><img src="/2021/05/22/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2Nexus/user-role-bind.png"></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署SonarQube</title>
    <url>/2021/05/13/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2SonarQube/</url>
    <content><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>搭建PostgreSQL数据库</li>
<li>搭建SonarQube</li>
<li>配置LDAP登录</li>
</ol>
<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3></li>
<li>postgres 13.2</li>
<li>sonarqube 8.9.0-community</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建NFS-Provisioner"><a href="#创建NFS-Provisioner" class="headerlink" title="创建NFS Provisioner"></a>创建NFS Provisioner</h3><h3 id="创建PostgreSQL-和-SonarQube资源清单"><a href="#创建PostgreSQL-和-SonarQube资源清单" class="headerlink" title="创建PostgreSQL 和 SonarQube资源清单"></a>创建PostgreSQL 和 SonarQube资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/sonar">资源清单</a></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/sonar</span><br><span class="line">kubectl apply -f .</span><br></pre></td></tr></table></figure>

<h3 id="访问web页面"><a href="#访问web页面" class="headerlink" title="访问web页面"></a>访问web页面</h3><p>访问 http://[nodeIp]:30003</p>
<p>默认用户名: admin</p>
<p>默认密码: admin</p>
<p>首次登录后会要求修改密码</p>
<h2 id="配置ldap"><a href="#配置ldap" class="headerlink" title="配置ldap"></a>配置ldap</h2><p>在挂载卷路径下的conf文件夹中，新建或修改SonarQube的配置文件sonar.properties</p>
<p>根据<a href="https://docs.sonarqube.org/latest/instance-administration/delegated-auth">官方示例及相关配置项说明</a>将其修改为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># General Configuration</span></span><br><span class="line"><span class="meta">sonar.security.realm</span>=<span class="string">LDAP</span></span><br><span class="line"><span class="comment"># 这里使用了svc的名称，可以换成ip</span></span><br><span class="line"><span class="meta">ldap.url</span>=<span class="string">ldap://ldap-service:389</span></span><br><span class="line"><span class="comment"># 管理员的账号密码</span></span><br><span class="line"><span class="meta">ldap.bindDn</span>=<span class="string">cn=admin,dc=example,dc=org</span></span><br><span class="line"><span class="meta">ldap.bindPassword</span>=<span class="string">admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># User Configuration</span></span><br><span class="line"><span class="comment"># 用户的搜索路径，LDAP中用户的根节点</span></span><br><span class="line"><span class="meta">ldap.user.baseDn</span>=<span class="string">cn=ldap,dc=example,dc=org</span></span><br><span class="line"><span class="comment"># 制定搜索规则</span></span><br><span class="line"><span class="comment">#ldap.user.request=(&amp;(objectClass=inetOrgPerson)(uid=$&#123;login&#125;))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Group Configuration</span></span><br><span class="line"><span class="comment"># 用户组的搜索路径，LDAP中组的根节点</span></span><br><span class="line"><span class="meta">ldap.group.baseDn</span>=<span class="string">dc=example,dc=org</span></span><br><span class="line"><span class="comment"># 制定搜索规则</span></span><br><span class="line"><span class="comment">#ldap.group.request=(&amp;(objectClass=posixGroup)(gid=&#123;dn&#125;))</span></span><br></pre></td></tr></table></figure>

<p>修改后，使用<code>kubectl delete pod </code>删除sonarqube的Pod，重启sonarqube服务。使用ldap中的用户和密码测试登录是否成功。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Sonar</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战之部署ldap</title>
    <url>/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2ldap/</url>
    <content><![CDATA[<h2 id="环境及镜像版本说明"><a href="#环境及镜像版本说明" class="headerlink" title="环境及镜像版本说明"></a>环境及镜像版本说明</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>CentOS 7.6</li>
<li>Kubernetes 1.18.15</li>
<li>Docker 19.03.9<h3 id="Docker-Image版本"><a href="#Docker-Image版本" class="headerlink" title="Docker Image版本"></a>Docker Image版本</h3></li>
<li>osixia/openldap stable</li>
<li>osixia/phpldapadmin stable</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建NFS共享目录"><a href="#创建NFS共享目录" class="headerlink" title="创建NFS共享目录"></a>创建NFS共享目录</h3><ol>
<li>创建NFS服务</li>
<li>依次创建目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/nfs/data/ldapdata</span><br><span class="line">mkdir /usr/nfs/data/ldapdata/db</span><br><span class="line">mkdir /usr/nfs/data/ldapdata/config</span><br><span class="line">mkdir /usr/nfs/data/ldapdata/certs</span><br></pre></td></tr></table></figure>

<h3 id="创建ldap资源清单"><a href="#创建ldap资源清单" class="headerlink" title="创建ldap资源清单"></a>创建ldap资源清单</h3><p><a href="https://github.com/Owl0214/DevOps/tree/main/ldap">ldap资源清单</a></p>
<h3 id="启动ldap和web管理页面"><a href="#启动ldap和web管理页面" class="headerlink" title="启动ldap和web管理页面"></a>启动ldap和web管理页面</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply ldap-deployment.yaml</span><br><span class="line">kubectl apply ldap-service.yaml</span><br><span class="line">kubectl apply phpldapadmin-deployment.yaml</span><br><span class="line">kubectl apply phpldapadmin-service.yaml</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/12/DevOps/DevOps%E5%AE%9E%E6%88%98%E4%B9%8B%E9%83%A8%E7%BD%B2ldap/ldap-svc.png"></p>
<h3 id="访问Web页面"><a href="#访问Web页面" class="headerlink" title="访问Web页面"></a>访问Web页面</h3><p>访问http://[NodeIp]:30080/</p>
<p>默认用户名：cn=admin,dc=example,dc=org</p>
<p>默认密码：admin</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>ldap</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Namespace</title>
    <url>/2021/08/21/Kubernetes/Docker/namespace/</url>
    <content><![CDATA[<h1 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h1><p>Linux Namespace是一种隔离机制，它将全局系统资源包装起来，使得PID、IPC、Network、Mount、UTS、User、CGroup不再是全局性的，而是属于特定的Namespace。每个Namespace下的资源对于其他Namespace都是不可见的。</p>
<p>一个进程可以属于多个Namespace。</p>
<h2 id="Namespace种类"><a href="#Namespace种类" class="headerlink" title="Namespace种类"></a>Namespace种类</h2><table>
<thead>
<tr>
<th>namespace 名称</th>
<th>系统调用参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>隔离一组进程看到的文件系统的挂载点，不同的命名空间可以具有不同的文件系统结构</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>隔离进程编号，PID 命名空间的主要好处之一是容器可以在主机之间迁移，同时为容器内的进程保留相同的进程 ID。PID 命名空间还允许每个容器拥有自己的 init (PID 1)，即“所有进程的祖先”，管理各种系统初始化任务并在它们终止时回收孤立的子进程。</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>隔离网络设备，堆栈，端口等</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>隔离进程间通信系统 IPC, POSIX 消息队列</td>
</tr>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>隔离节点名和域名</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>隔离用户和组ID</td>
</tr>
<tr>
<td>Cgroup</td>
<td>CLONE_NEWCGROUP</td>
<td>隔离Cgroup 根目录，可以防止信息泄露而导致cgroup目录路径外部进程可见；隔离后，Cgroup路径名是独立的，容器迁移时，防止cgroup路径名与目标系统上的路径名发生冲突;将cgroup文件系统完全隔离开，可以防止容器进程无法访问主机的cgroup目录</td>
</tr>
</tbody></table>
<p>每种namespace各有自己管理的部分，<strong>对于现在 Linux 上的任意进程而言，它一定是<code>每种 namespace 的一个实例</code></strong> (<strong>就是每个进程都得归属于某个ns，ns中可以只有一个进程，也可以由多个进程共有</strong>)</p>
<p>隔离cgroup说明：假设一个场景，有一个cgroup目录<code>/cg/1</code>，它归USER ID 9000所有，有一个进程X也归USER ID 9000所有，该进程的命名空间位于cgroup目录<code>/cg/1/2</code>。在没有cgroup命名空间的情况下，因为cgroup目录<code>/cg/1</code>由UID 9000拥有（可写）并且进程X也由UID 9000所有，进程X则既能修改<code>/cg/1</code>的文件，也能修改<code>/cg/1/2</code>的文件。通过cgroup namespace，可以防止进程X修改<code>/cg/1</code>的中的文件，因为它看不到该目录。这样可以防止进程X逃逸其ancestor cgroup的限制。</p>
<p><strong>Linux 提供了以下主要的系统调用</strong>用于管理namespace：</p>
<ul>
<li>clone()：如果是纯粹只使用clone()，则会创建一个新进程；但如果我们传递一个或多个 CLONE_NEW* 标志参数给clone()，则会根据每个标志创建对应的新namespace 并且将子进程添加为其成员，达到隔离效果。</li>
<li>setns()：允许进程加入一个已存在的 namespace 中。</li>
<li>unshare()：允许进程（或线程）取消其执行上下文中，与其他进程（或线程）共享部分的关联，通俗点来说，也就是可以利用此系统调用来让当前的进程（或线程）移动至一个新的namespace中。</li>
</ul>
<h3 id="隔离IPC"><a href="#隔离IPC" class="headerlink" title="隔离IPC"></a>隔离IPC</h3><p>IPC 全称 Inter-Process Communication，是进程间通信的一种方式，IPC有管道、共享内存、信号量、消息队列、信号、套接字。</p>
<ol>
<li>查看主机信号量<br><img src="/2021/08/21/Kubernetes/Docker/namespace/ipcs1.png"></li>
<li>主机上创建信号量</li>
</ol>
<blockquote>
<p>ipcmk -S 10</p>
</blockquote>
<blockquote>
<p>ipcs</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ipcs_host.png"></p>
<ol>
<li>创建一个新的IPC Namespace，然后查看ns中的信号量<blockquote>
<p>unshare –ipc</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ipcs_ns.png"></p>
<h3 id="隔离UTS"><a href="#隔离UTS" class="headerlink" title="隔离UTS"></a>隔离UTS</h3><p>UTS(Unix Timesharing System)命名空间包含了运行内核的名称、版本、底层体系结构类型等信息</p>
<blockquote>
<p>unshare –uts<br>hostname<br>hostname test<br>hostname</p>
</blockquote>
<p>查看ns中的hostname和主机上的name<br>分别为<code>test</code>和<code>edunode1</code></p>
<h3 id="隔离User"><a href="#隔离User" class="headerlink" title="隔离User"></a>隔离User</h3><p>隔离user namespace</p>
<blockquote>
<p>unshare –user</p>
</blockquote>
<p>可以通过-r参数，把新的namespace中的root用户映射成宿主机上的用户，例如，把ns中的用户映射为宿主机的root</p>
<blockquote>
<p>unshare –user -r root</p>
</blockquote>
<h3 id="隔离PID"><a href="#隔离PID" class="headerlink" title="隔离PID"></a>隔离PID</h3><blockquote>
<p>unshare –pid</p>
</blockquote>
<p>观察主机上的进程<br><img src="/2021/08/21/Kubernetes/Docker/namespace/pid_host.png"></p>
<p>观察PID namespace中的进程<br><img src="/2021/08/21/Kubernetes/Docker/namespace/pid_ns.png"></p>
<h3 id="隔离Network"><a href="#隔离Network" class="headerlink" title="隔离Network"></a>隔离Network</h3><ol>
<li>创建netns<blockquote>
<p>ip netns add ns1</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ip netns list</p>
</blockquote>
<ol start="2">
<li>查看ns1中的网络，通过ip netns exec执行在ns中执行响应命令</li>
</ol>
<blockquote>
<p>ip netns exec ns1 ip addr</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ip_netns_ipaddr.png"></p>
<ol start="3">
<li>测试网络连通性<blockquote>
<p>ip netns exec ns1 ping 10.6.8.113</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/ip_netns_ping.png"></p>
<h4 id="通过veth-pair与宿主机、其他ns进行网络通信"><a href="#通过veth-pair与宿主机、其他ns进行网络通信" class="headerlink" title="通过veth pair与宿主机、其他ns进行网络通信"></a>通过veth pair与宿主机、其他ns进行网络通信</h4><ol>
<li>创建veth pair</li>
</ol>
<blockquote>
<p>ip link add veth0 type veth peer name veth1</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/create_veth_pair.png"></p>
<ol start="2">
<li><p>将veth0或者veth1移动到ns1中</p>
<blockquote>
<p>ip link set veth1 netns ns1</p>
</blockquote>
</li>
<li><p>配置ip</p>
<blockquote>
<p>ip netns exec ns1 ifconfig veth1 192.168.10.100/24</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ifconfig veth0 192.168.10.101/24</p>
</blockquote>
<ol start="4">
<li>将网卡启动<blockquote>
<p>ip netns exec ns1 ifconfig veth1 up</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/vethpeer_in_ns.png"></p>
<blockquote>
<p>ifconfig veth0</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/namespace/vethpeer_in_host.png"></p>
<ol start="5">
<li>测试<blockquote>
<p>ip netns exec ns1 ping 192.168.10.101</p>
</blockquote>
</li>
</ol>
<p>同理，可将veth peer分别放在两个netns中进行联通</p>
<h4 id="通过bridge中转"><a href="#通过bridge中转" class="headerlink" title="通过bridge中转"></a>通过bridge中转</h4><p>实际使用中，不可能每2个不同的ns都进行一次veth pair配置，这时就需要Linux Bridge来做转发，将veth pair中的一个veth peer绑定到ns中，另一端绑定到bridge上。</p>
<ol>
<li>创建两个netns，和两对veth pair<blockquote>
<p>ip netns add ns0<br>ip netns add ns1</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ip link add veth0 type veth peer name br-veth0<br>ip link add veth1 type veth peer name br-veth1</p>
</blockquote>
<ol start="2">
<li>创建bridge，并启动网桥<blockquote>
<p>brctl addbr br0</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>ip link set br0 up</p>
</blockquote>
<ol start="3">
<li>将veth pair中的一端分别加入到ns中，另一端放到bridge上</li>
</ol>
<p>将veth0放入ns0中，并配置ip</p>
<blockquote>
<p>ip link set veth0 netns ns0<br>ip netns exec ns0 ifconfig veth0 192.168.10.100/24 up<br>ip netns exec ns0 ip link set lo up</p>
</blockquote>
<p>将br-veth0绑定到网桥br0上，并启动br-veth0</p>
<blockquote>
<p>brctl addif br0 br-veth0<br>ip link set br-veth0 up</p>
</blockquote>
<p>将veth1放入ns1中，并配置ip，启动lo</p>
<blockquote>
<p>ip link set veth1 netns ns1<br>ip netns exec ns1 ifconfig veth1 192.168.10.101/24 up<br>ip netns exec ns1 ip link set lo up</p>
</blockquote>
<p>将br-veth1绑定到网桥br0上，并启动br-veth1</p>
<blockquote>
<p>brctl addif br0 br-veth1<br>ip link set br-veth1 up</p>
</blockquote>
<p>通过<code>brctl show</code>查看网桥<br><img src="/2021/08/21/Kubernetes/Docker/namespace/bridge.png"></p>
<ol start="4">
<li>连通性测试<blockquote>
<p>ip netns exec ns0 ping 192.168.10.101<br><img src="/2021/08/21/Kubernetes/Docker/namespace/connected.png"></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>cgroup</title>
    <url>/2021/08/21/Kubernetes/Docker/cgroup/</url>
    <content><![CDATA[<h1 id="Linux-cgroup"><a href="#Linux-cgroup" class="headerlink" title="Linux cgroup"></a>Linux cgroup</h1><p>cgroups(Control Groups)通过不同的子系统限制了不同的系统资源，每种子系统限制一种资源。每个子系统限制资源的方式都是类似的，就是把相关的一组进程分配到一个控制组中，然后通过树结构(hierarchy)进行管理。每个控制组设有自己的资源控制参数。</p>
<p>默认情况下，系统中，所有进程位于同一个cgroup，就是根，这个cgroup享有所有的系统资源。</p>
<p>通过cgroup文件系统可以建立一个新的cgroup，可以为其分配进程、资源等。</p>
<p>通过<code>mount</code>查看系统中已经挂载的cgroup。cgroup的根目录是以tmpfs的性质进行挂载的，<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/cgroup-mounttype.png"></p>
<p>通过cgroup可以将定额的系统资源（如CPU、内存等）分配给特定的一组进程。cgroup的主要功能包括：</p>
<ul>
<li>Resource limitation：资源限制，比如限制内存使用上限</li>
<li>Prioritization：优先级分配，通过分配CPU时间片数量及硬盘IO带宽大小，来控制进程运行的优先级</li>
<li>Accounting：资源统计，比如CPU使用时长、内存用量等。</li>
<li>Control：进程控制，比如挂起进程、恢复执行进程</li>
</ul>
<h2 id="cgroup子系统"><a href="#cgroup子系统" class="headerlink" title="cgroup子系统"></a>cgroup子系统</h2><p>cgroup本身是分层级的，一个根层下面像一棵树一样可以分很多层。每一层的cgroup文件系统目录下都有改成对应的资源配置文件。这些可以配置的文件都是cgroup子系统。</p>
<p>通过<code>lssubsys -m</code>，可以查看cgroup的子系统。在<code>/sys/fs/cgroup</code>下有cgroup的子目录，这些子目录均为cgroup的子系统。<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/cgroup-subsystem.png"></p>
<p>cgroup包含的子系统有：</p>
<ul>
<li>cpu：用于控制cgroup中所有进程可以使用的CPU时间片。主要限制进程的cpu使用率</li>
<li>cpuacct：可以生成cgroups中的进程的cpu使用报告</li>
<li>cpuset：对于多核cpu，可以为cgroups中的进程分配单独的cpu节点或者内存节点</li>
<li>memory：可以限制进程的memory使用量</li>
<li>blkio：可以限制进程的块设备io</li>
<li>devices：可以控制进程能够访问某些设备。通过提供device whilelist实现的，devices子系统通过在内核对设备访问的时候加入额外的检查实现。devices子系统本身只需要管理好设备访问列表。</li>
<li>net_cls：可以标记cgroups中进程的网络数据包，然后可以使用tc模块(traffic control)对数据包进行控制，限制网络带宽</li>
<li>net_prio：用来设计网络流量的优先级，对每个网络接口指定优先级</li>
<li>freezer：可以挂起或者恢复cgroups中的进程。freezer.state可能读出的值有3种，分贝是FROZEN（已挂起）、THAWED（正常运行、已恢复）、FREEZING（该值代表cgroup中有些进程现在不能被frozen，当这些进程从该cgroup消失时，FREEZING会变成FROZEN）</li>
<li>ns：可以使不同cgroups下面的进程使用不同的namespaces。ns子系统没有自己的控制文件，而且没有属于自己的状态信息。ns子系统实际上是提供了一种同命名空间的进程聚类的机制。具有相同命名空间的进程会在相同的cgroup分组中。</li>
<li>hugetlb：主要针对于HugeTLB系统（大页文件系统）进行限制</li>
<li>perf_event：对cgroup中的进程组进行性能监控</li>
<li>pids：限制在cgroup中创建的进程数量</li>
<li>rdma：限制cgroup中使用的rdma(Remot Direct Memory Access)</li>
</ul>
<h3 id="CPU子系统"><a href="#CPU子系统" class="headerlink" title="CPU子系统"></a>CPU子系统</h3><p>用于控制cgroup中所有进程可以使用的CPU时间片，cpu子系统下的cgroup目录中，存在一个cpu.shares的文件，对其写入整数值，可以控制该cgroup获得的时间片。</p>
<p>例如，在两个相同层级的cgroup中，都将cpu.shares设置为1，那么这两个cgroup将会有相同的CPU时间。如果将其中一个cgroup中的cpu.shares设置为2，那么该cgroup中可使用CPU时间是另一个cgroup中可使用CPU时间的两倍。</p>
<p>CPU子系统通过Linux CFS调度器(Completely Fair Scheduler)实现的，CPU子系统调度CPU访问控制有两种模式：CFS(Completely Fair Scheduler)和RTS(Real-Time Scheduler)，RTS的方式只有在进程中采用了RTS调度算法时才生效。</p>
<h3 id="cpuacct子系统"><a href="#cpuacct子系统" class="headerlink" title="cpuacct子系统"></a>cpuacct子系统</h3><p>cpuacct子系统自动生成cgroup中任务所使用的CPU报告。</p>
<ul>
<li>cpuacct.usage：该group及其子group的CPU总使用时间(ns)</li>
<li>cpuacct.stat：该group及其子group的CPU的用户态和内核态的分别使用时间(ns)</li>
<li>cpuacct.usage_percpu：该group及其子group的CPU分别使用时间(ns)</li>
</ul>
<h3 id="cpuset子系统"><a href="#cpuset子系统" class="headerlink" title="cpuset子系统"></a>cpuset子系统</h3><p>为cgroup中的任务分配独立的CPU（多核系统中）和内存节点。</p>
<ul>
<li>cpuset.cpus：绑定该group的CPU节点，如绑定该进程可以使用0、1、2、6、8这5个CPU，写入文件数据格式是”0-2,6,8”</li>
</ul>
<h3 id="memory子系统"><a href="#memory子系统" class="headerlink" title="memory子系统"></a>memory子系统</h3><p>可以设定cgroup中任务使用的内存限制，并自动生成由哪些任务使用的内存资源报告。memory子系统是通过Linux的resource counter机制实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> usage; <span class="comment">//记录资源的当前使用量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> max_usage; <span class="comment">//使用过的最大资源量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> limit; <span class="comment">//资源最大限制，分配超过此限制的资源将会导致失败</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> soft_limit; <span class="comment">//资源软限制，可以超过这个值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> failcnt; <span class="comment">//资源分配失败的次数</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock; <span class="comment">//自旋锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> *<span class="title">parent</span>;</span> <span class="comment">//形成资源统计组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>/sys/fs/cgroup/memory</code>下，创建文件夹<code>mkdir test</code>，即创建了一个子cgroup，子cgroup中的文件包含如下：<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/cgroup-memory-newtask.png"></p>
<ul>
<li>cgroup.event_control：用于eventfd的接口</li>
<li>memory.usage_in_bytes：显示当前已用的内存</li>
<li>memory.limit_in_bytes：设置/显示当前限制的内存额度</li>
<li>memory.failcnt：显示内存使用量达到限制值的次数</li>
<li>memory.max_usage_in_bytes：历史内存最大使用量</li>
<li>memory.soft_limit_in_bytes：设置/显示当前限制的内存软额度</li>
<li>memory.stat：显示当前cgroup的内存使用情况</li>
<li>memory.use_hierarchy：设置/显示是否将子cgroup的内存使用情况统计到当前cgroup里面</li>
<li>memory.force_empty：触发系统立即尽可能的回收当前cgroup中可以回收的内存</li>
<li>memory.pressure_level：设置内存压力的通知事件，配合cgroup.event_control一起使用</li>
<li>memory.swappiness：设置和显示当前的swappiness</li>
<li>memory.move_charge_at_immigrate：设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去</li>
<li>memory.oom_control：设置/显示oom controls相关的配置</li>
<li>memory.numa_stat：显示numa相关的内存</li>
</ul>
<h4 id="设置内存限制"><a href="#设置内存限制" class="headerlink" title="设置内存限制"></a>设置内存限制</h4><p>操作cgroup主要有以下3步：</p>
<ol>
<li>创建cgroup</li>
<li>设置cgroup参数</li>
<li>将进程PID写入cgroup的task</li>
</ol>
<p>例如设置内存限制步骤如下：</p>
<ol>
<li>创建新的cgroup<blockquote>
<p>cd /sys/fs/cgroup/memory<br>mkdir test<br>cd test</p>
</blockquote>
</li>
<li>设置memory.limit_in_bytes和memory.memsw.limit_in_bytes<br>memory.limit_in_bytes用于限制memeory的大小，memory.memsw.limit_in_bytes用于限制memeory+swap的大小。memory.memsw.limit_in_bytes的值应大于等于memory.limit_in_bytes<blockquote>
<p>cat memory.limit_in_bytes</p>
</blockquote>
</li>
</ol>
<p>9223372036854771712</p>
<blockquote>
<p>echo 100M &gt; memory.limit_in_bytes<br>cat memory.limit_in_bytes</p>
</blockquote>
<p>104857600</p>
<ol start="3">
<li>将bash设置到tasks中，并创建一个200M的文件<blockquote>
<p>echo $$&gt;tasks<br>dd if=/dev/zero of=/home/myfile bs=200M count=1</p>
</blockquote>
</li>
</ol>
<p>Killed</p>
<h3 id="blkio子系统"><a href="#blkio子系统" class="headerlink" title="blkio子系统"></a>blkio子系统</h3><p>为块设备设定输入/输出限制，比如物理设备(磁盘、固态硬盘、USB等)。</p>
<p>该子系统提供了两种控制I/O的方式：</p>
<ol>
<li>基于权重，每个group都可以设置一个数值，根据数值不同，系统分配响应的I/O。以下两个值同一个group中只能存在一个。<ul>
<li>blkio.weight：一个100~1000的数值，全局的权重</li>
<li>blkio.weight_device：一个100~1000的数值，指定设备的I/O的权重。会覆盖全局的权重值</li>
</ul>
</li>
<li>基于速度，每个group都有一个最大的速度，该group的进程I/O不能大于这个速度<ul>
<li>blkio.throttl.read_bps_device：指定该设备上的最大读速度(bytes/s)</li>
<li>blkio.throttle.read_iops_device：指定该设备上的最大读I/O (I/O read/s);</li>
<li>blkio.throttle.write_bps_device：指定该设备上最大写速度(bytes/s)</li>
<li>blkio.throttle.write_iops_device：指定该设备上的最大写IO(I/O read/s)</li>
<li>blkio.throttle.io_serviced：记录设备I/O操作总数</li>
<li>blkio.throttle.io_service_bytes：记录设备读取总数</li>
</ul>
</li>
</ol>
<p>其他参数：</p>
<ul>
<li>blkio.reset_stats：对当前文件写入一个整数可重置当前所有统计数据</li>
<li>blkio.time：指定设备的cgroup控制的I/O访问时间(ms)</li>
<li>blkio.sectors：指定设备的扇区操作数</li>
<li>blkio.io_service_time：指定设备的I/O工作时间(ns)</li>
<li>blkio.io_wait_time：cgroup等待I/O的时间</li>
<li>blkio.io_merged：被合并的I/O请求</li>
<li>blkio.io_queued：被cgroup放到队列的I/O请求</li>
</ul>
<h2 id="hierarchy"><a href="#hierarchy" class="headerlink" title="hierarchy"></a>hierarchy</h2><p>一个hierarchy是一组排列在树中的cgroups，树中的每个节点都是一个进程组，系统中的每一个任务都在其中的一个cgroup中，每棵树会关联到多个subsystem。系统中可以有多棵cgroup树。</p>
<p>通过<code>systemd-cgls</code>可已查看Linux cgroup层次结构树。可以显示指定控制组的所有成员进程及其子组和成员。例如：</p>
<blockquote>
<p>systemd-cgls / kubepods</p>
</blockquote>
<p><img src="/2021/08/21/Kubernetes/Docker/cgroup/systemd-cgls.png"></p>
<p>系统阶段，systemd会将它在内核中找到的所有hierarchies挂载到<code>/sys/fs/cgroup</code>下的各个目录。除了<code>/sys/fs/cgroup/systemd</code>目录，其他目录都是对应的子系统。<code>/sys/fs/cgroup/systemd</code>是systemd维护自己使用的，不允许其他程序移动这个目录的内容。</p>
<p>通过将cgroup hierarchy系统绑定到systemd单元树上，systemd可以将资源管理的设置从进程级别移动带应用程序级别。因此，可以使用systemctl指令或者修改systemd单元的配置文件来管理单元相关的资源。</p>
<p>默认情况下，systemd会自动创建slice、scope和service三个层次结构：</p>
<ul>
<li>service：systemd基于单元配置文件启动的一个进程或一组进程。服务封装了指定的进程，以便它们可以作为一个集合启动和停止。服务以<code>name.service</code>的形式被命名。</li>
<li>scope：一组外部创建的进程。Scopes封装了由任意进程通过fork()函数启动和停止的进程，然后在运行时，由systemd注册这些进行。例如，用户会话、容器和虚拟机被视为作用域。作用域以<code>name.scope</code>的形式被命名。</li>
<li>slice：一组分层组织的单元。Slices不包含进程，他们组织了一个层级结构，其中放置了scope和service。实际的进程都包含在scope和service中。在这个层次树中，切片单元的每个名称都对应于层次结构中某个位置的路径。<code>-</code>字符用作路径组件的分隔符。切片以<code>parent-name.slice</code>的形式被命名。slice是parent的子切片。一个根切片表示为<code>-.slice</code></li>
</ul>
<p>服务、范围和切片单元直接映射到cgroup树中的对象。当这些单元被激活时，它们会直接映射到根据单元名称构建的 cgroup路径。例如，ex.service属于test-waldo.slice，会直接映射到<code>cgroup test.slice/test-waldo.slice/ex.service/</code>中。</p>
<h3 id="Subsystem、Hierarchies、Control-Groups、Task的关系"><a href="#Subsystem、Hierarchies、Control-Groups、Task的关系" class="headerlink" title="Subsystem、Hierarchies、Control Groups、Task的关系"></a>Subsystem、Hierarchies、Control Groups、Task的关系</h3><ol>
<li><p>一个hierarchy可以附加一个或者多个subsystem（同时参照规则2）。例如cpu子系统和memory子系统（或任意数量的子系统）可以附加到单个层次结构。<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/RMG-rule1.png"></p>
</li>
<li><p>任何single subsystem（例如cpu）都不能附加到多个hierarchy上。如果第二个hierarchy没有其他的subsystem，那么就可以依附，即可以存在两个都仅有cpu依附的hierarchy；如果第二个hierarchy上依附了其他的subsystem，那么就不能依附。如图，图中的编号表示子系统所附的时间序列，因为 Hierarchy B依附了其他系统，所以cpu子系统就不能依附了。<br><img src="/2021/08/21/Kubernetes/Docker/cgroup/RMG-rule2.png"></p>
</li>
<li><p>每次在系统上创建新的hierarchy时，系统上所有task（进程）最初都是该层次结构的默认cgroup的成员，该cgroup称为<code>root cgroup</code>，在这个hierarchy中创建的所有<code>cgroup</code>都是这个<code>root cgroup</code>的子节点。对于创建的任何一个hierarchy，系统上每个task都可以是该层次结构中的一个cgroup的成员。</p>
<p> 一个task可以在多个cgroup中，只要这个task所在的每个cgroup在不同的hierarchy中。如果一个task成为同一个hierarchy中第二个cgroup的成员，那么他就会从该hierarchy中的第一个cgroup中删除。</p>
<p> 任何时候，同一个hierarchy的不同cgroup中，不会存在同一个task。</p>
<p> 如图，如果cpu和内存子系统连接到名为cpu_mem_cg的hierarchy中，而net_cls子系统连接到名为net的hierarchy中，那么httpd进程可以是cpu_mem_cg中任何一个cgroup的成员，也可以是net中的任何一个cgroup的成员，但其不能同时存在于cpu_mem_cg中的两个cgroup中。</p>
<p> 因为当创建第一个hierarchy时，系统上的每个task都至少是一个cgroup(root cgroup)的成员，所以，当使用cgroups时，每个task总是至少在一个cgroup中。<br> <img src="/2021/08/21/Kubernetes/Docker/cgroup/RMG-rule3.png"></p>
</li>
<li><p> 一个进程(task)fork出子进程时，子进程会自动继承父进程的cgroup成员。也可以将子task移动到不同的cgroup中。当fork完成，父子进程就完全独立了。</p>
<h2 id="cgroup1和cgroup2"><a href="#cgroup1和cgroup2" class="headerlink" title="cgroup1和cgroup2"></a>cgroup1和cgroup2</h2><p>当前kernel中允许cgroup v1版本和v2版本共存。<br>Cgroup v2将多hierarchy的方式变成了unified hierarchy，并将所有的controller挂载到一个unified hierarchy。</p>
</li>
</ol>
<p>主要改进：</p>
<ul>
<li>Cgroups v2 中所有的controller都会被挂载到一个unified hierarchy下，不在存在像v1中允许不同的controller挂载到不同的hierarchy的情况</li>
<li>Process只能绑定到cgroup的根(<code>/</code>)目录和cgroup目录树中的叶子节点</li>
<li>通过cgroup.controllers和cgroup.subtree_control指定哪些controller可以被使用</li>
<li>v1版本中的task文件和cpuset controller中的cgroup.clone_children文件被移除</li>
<li>当cgroup为空时的通知机制得到改进，通过cgroup.events文件通知</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://0pointer.de/blog/projects/cgroups-vs-cgroups.html">cgroups</a></li>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/resource_management_guide/index">Red Hat Enterprise Linux 7 的系统资源</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">Control Group v2</a></li>
<li><a href="https://blog.51cto.com/u_15127564/2666789">浅谈Cgroups v2</a></li>
<li><a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/">Docker 背后的内核知识——cgroups 资源限制</a></li>
<li><a href="https://www.lijiaocn.com/%E6%8A%80%E5%B7%A7/2019/01/28/linux-tool-cgroup-detail.html">Linux的cgroup功能（二）：资源限制cgroup v1和cgroup v2的详细介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>存储之NFS</title>
    <url>/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>NFS(Network FileSystem)，可以通过网络，让不同的机器、不同的操作系统可以分享文件。可以看作是一个文件服务器(File Server)。</p>
<p>NFS服务器可以将源成的NFS服务器分享的目录，挂载到客户端的机器中。当服务器端将系统目录分享出来后。其他客户端就可以将这个目录挂载到自己系统上的挂载点上。</p>
<p><img src="/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/nfs_server_client.png"></p>
<p>NFS使用网络进行数据的传输，NFS服务端与客户端之间通过RPC。服务器在启动时，会随机取用数个端口，并主动向RPC注册。因此RPC可以知道每个端口的功能。客户端上，RPC固定使用111端口，来监听客户端的请求，并响应给客户端对应服务正确的端口。</p>
<p><img src="/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/nfs_rpc.png"></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="安装配置NFS"><a href="#安装配置NFS" class="headerlink" title="安装配置NFS"></a>安装配置NFS</h2><ol>
<li>安装NFS<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install nfs-utils rpcbind -y</span><br></pre></td></tr></table></figure></li>
<li>创建共享目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/exports</span><br><span class="line"></span><br><span class="line">/usr/nfs  10.0.38.0/24(rw,no_root_squash,sync)</span><br><span class="line"></span><br><span class="line"># exportfs -r</span><br></pre></td></tr></table></figure></li>
</ol>
<p>exports文件说明：<br>内容格式应为： <code>&lt;输出目录&gt; [客户端](参数...) [客户端2](参数...)</code></p>
<p>说明：</p>
<ul>
<li>输出目录：本地需要共享给客户端的文件夹路径</li>
<li>客户端：<ul>
<li>可以指定ip，如10.0.38.82</li>
<li>可以指定子网，如10.0.38.0/24</li>
<li>可以指定主机名</li>
<li>可以指定域中的所有主机，如*.[域名]</li>
<li>指定所有主机： *</li>
</ul>
</li>
<li>可选参数之间用逗号分隔<table>
<thead>
<tr>
<th>参数值</th>
<th>内容说明</th>
</tr>
</thead>
<tbody><tr>
<td>rw<br>ro</td>
<td>该目录分享的权限是可读写(read-write)或只读(read-only)，但最终能不能读写，还是与文件系统的rwx及身份有关</td>
</tr>
<tr>
<td>sync<br>async</td>
<td>sync代表数据会同步写入到内存与硬盘中。async代表数据会先暂存于内存当中，而非直接写入硬盘</td>
</tr>
<tr>
<td>no_root_squash<br>root_squash</td>
<td>客户端使用NFS文件系统的账号若为root时，系统该如何判断这个账号的身份？预设的情况下，客户端root的身份会由root_squash的设定压缩成nfsnobody，如此对服务器的系统会交由保障。但如果想要开放客户端使用root身份来操作服务器的文件系统，那么就需要开no_root_squash才行</td>
</tr>
<tr>
<td>all_squash</td>
<td>不论登入NFS的使用者是什么身份，他的身份都会被压缩为匿名用户(nobody(nfsnobody))</td>
</tr>
<tr>
<td>anonuid<br>anongid</td>
<td>anon指anonymous(匿名者)。关于*_squash提到的匿名用户的UID设定值，通常为nobody(nfsnobody)，但是可以自行设定这个UID的值。当然，这个UID必须要存在于你的/etc/passwd当中。anonuid指的是UID而anongid则是群组的GID</td>
</tr>
</tbody></table>
</li>
</ul>
<ol start="3">
<li>启动服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start rpcbind &amp;&amp; systemctl enable rpcbind</span><br><span class="line">systemctl start nfs &amp;&amp; systemctl enable nfs</span><br></pre></td></tr></table></figure>
通过showmount [-ae] [hostname|ip]查看共享目录</li>
</ol>
<ul>
<li>-a:显示目前主机与客户端的NFS联机分享的状态</li>
<li>-e:显示某主机的的/etc/exports所分享的目录数据</li>
</ul>
<p><img src="/2021/05/22/Kubernetes/Storage/%E5%AD%98%E5%82%A8%E4%B9%8BNFS/nfs-show-mount.png"></p>
<h1 id="k8s使用nfs-client-provisioner，创建PV和PVC"><a href="#k8s使用nfs-client-provisioner，创建PV和PVC" class="headerlink" title="k8s使用nfs-client-provisioner，创建PV和PVC"></a>k8s使用nfs-client-provisioner，创建PV和PVC</h1><p>nfs-client-provisioner使用现有的和已配置的NFS服务器来支持通过持久卷声明动态配置 Kubernetes 持久卷。其本身不提供NFS，需要现有的NFS服务器提供存储。</p>
<ul>
<li>PV以<code>&#123;namespace&#125;-&#123;pvcName&#125;-&#123;pvName&#125;</code>的命名格式提供</li>
<li>PV回收时以<code>archieved-&#123;namespace&#125;-&#123;pvcName&#125;-&#123;pvName&#125;</code>的命名格式提供</li>
</ul>
<p>k8s部署nfs-client-provisioner的<a href="https://github.com/Owl0214/DevOps/tree/main/nfs">清单文件</a>：</p>
<ul>
<li>deployment需要修改NFS服务器地址，以及NFS共享路径</li>
<li>官方配置说明参见<a href="https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner">NFS Ganesha server and external provisioner</a></li>
</ul>
<h2 id="使用NFS创建PV和PVC说明"><a href="#使用NFS创建PV和PVC说明" class="headerlink" title="使用NFS创建PV和PVC说明"></a>使用NFS创建PV和PVC说明</h2><ul>
<li><p>k8s 创建PVC时，需指定<code>storageClassName</code>，其值与StorageClass中配置的name相同。</p>
</li>
<li><p>StorageClass中指定了<code>provisioner: fuseim.pri/ifs</code>。其中<code>fuseim.pri/ifs</code>与<code>PROVISIONER_NAME</code>相同</p>
</li>
<li><p>绑定PV如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">mountPath:</span> &#123;<span class="string">container-filepath</span>&#125;</span><br><span class="line">          <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">nfs:</span> </span><br><span class="line">                <span class="attr">server:</span> &#123;<span class="string">nfs-server-ip</span>&#125;</span><br><span class="line">                <span class="attr">path:</span> &#123;<span class="string">nfs-shared-filepath</span>&#125;    </span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li>
<li><p>绑定PVC如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">mountPath:</span> &#123;<span class="string">container-filepath</span>&#125;</span><br><span class="line">          <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">              <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">                <span class="attr">claimName:</span> &#123;<span class="string">myapp-pvc</span>&#125;            </span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;<span class="string">myapp-pvc</span>&#125;</span><br><span class="line">  <span class="attr">namespace:</span> &#123;<span class="string">namespace</span>&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> &#123;<span class="string">StorageClass</span>&#125; <span class="comment"># StorageClass中配置的name</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span> <span class="comment">#存储卷大小</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h1><p><a href="http://cn.linux.vbird.org/linux_server/0330nfs.php">鸟哥的Linux私房菜–NFS服务器</a><br><a href="https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner">NFS Ganesha server and external provisioner</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Storage</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title>容器健康检查-探针机制</title>
    <url>/2021/08/27/Kubernetes/K8S/%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5-%E6%8E%A2%E9%92%88%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h1><p>k8s提供了三种探针，确保容器在部署后处于运行状态，这三种探针分别是：**就绪检测探针(readinessProbe)<strong>、</strong>存活检测探针(livenessProbe)<strong>、</strong>启动检测探针(startupProbe)**。</p>
<ul>
<li>livenessProbe用于检测容器是否处于健康状态，如果不健康，就<strong>删除重建</strong>。</li>
<li>readinessProbe用于检测启动时，容器状态是否就绪，当容器状态就绪，才开始接收请求流量，否则会从对应的Endpoint列表中被剔除。</li>
<li>startupProbe容器启动时执行，如果配置了startupProbe，就会在容器启动后再去执行livenessProbe和readinessProbe，避免容器内的应用程序在启动前就被杀掉。startupProbe检测成功后，就不会再进行检测。</li>
</ul>
<p>任何一种探针，都存在着3种状态：Success、Failure、Unknown，只有Success表示检测成功。其状态定义为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/results/results_manager.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Unknown Result = <span class="literal">iota</span> - <span class="number">1</span></span><br><span class="line">  Success</span><br><span class="line">  Failure</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Result)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> r &#123;</span><br><span class="line">  <span class="keyword">case</span> Success:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span></span><br><span class="line">  <span class="keyword">case</span> Failure:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Failure&quot;</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>k8s为每一种探针都提供了三种检测机制：</p>
<ul>
<li>HTTP GET Action：对容器的IP地址，指定端口和路径，执行HTTP GET请求。如果探测器收到响应，并且响应状态码不代表错误（状态码2xx或3xx），则认为检测成功。如果没收到响应，或返回错误状态码，则认为检测失败。</li>
<li>TCP Socket Action：尝试与容器指定的端口建立TCP连接，如果连接成功，则认为检测成功，反之检测失败</li>
<li>Exec Action：在容器内执行自定义的命令，并检查命令的退出状态码。如果状态码为0，则检测成功。其他所有状态码都会被认为失败。exec执行的指令，会占用容器内的资源，所以指令应当简单、轻量。</li>
</ul>
<p>每种探针都有通用的可配置字段：</p>
<ul>
<li>initialDelaySeconds：探测延迟时长，即容器启动多久后再开始第一次探测操作，显示为delay属性，默认为0秒</li>
<li>periodSeconds：探测的频度，默认为10秒，最小值为1秒。过高的频率会对Pod对象带来较大的额外开销，过低的频率有会使得对错误的反应不及时。</li>
<li>successThreshold：处于失败状态时，探测操作至少连续多少次成功才被认为是检测通过，默认值为1，最小值也为1</li>
<li>failureThreshold：处于成功状态时，探测操作至少连续多少次的失败才被视为检测不通过，默认值为3，最小值为1</li>
<li>timeoutSeconds：探测的超时时长，默认为1秒，最小是也为1秒</li>
</ul>
<h2 id="就绪探针-readinessProbe"><a href="#就绪探针-readinessProbe" class="headerlink" title="就绪探针(readinessProbe)"></a>就绪探针(readinessProbe)</h2><p>定义就绪探针意味着，Pod在启动阶段不接收任何数据，并且仅在探测成功时，才开始接收数据。</p>
<p>在Pod的整个生命周期中，就绪探针都会进行就绪探测，并确定Pod是否可以接收客户端请求，当容器就绪探针返回success时，表示容器已准备好接收请求。如果容器未通过<code>readinessProbe</code>检测，它不会被终止或重新启动，而是通知其尚未就绪，端点控制器(Endpoints Controller)会将该IP从所有匹配到此Pod的Serivce对象的Endpoint列表中删除。</p>
<p>就绪探针的状态值默认为Failure。<strong>如果容器未定义就绪探针，则容器默认状态为Success。</strong></p>
<p><img src="/2021/08/27/Kubernetes/K8S/%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5-%E6%8E%A2%E9%92%88%E6%9C%BA%E5%88%B6/readinessProbe.jpg"></p>
<h2 id="存活探针-livenessProbe"><a href="#存活探针-livenessProbe" class="headerlink" title="存活探针(livenessProbe)"></a>存活探针(livenessProbe)</h2><p>检查容器是否还在运行。可以为pod中的每个容器单独指定存活探针。如果探测失败，k8s将定期执行探针并重新启动容器。<strong>如果容器未定义存活探针，则容器默认状态为Success。</strong></p>
<h2 id="启动探针-startupProbe"><a href="#启动探针-startupProbe" class="headerlink" title="启动探针(startupProbe)"></a>启动探针(startupProbe)</h2><p>启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉。也可以延长readinessProbe和livenessProbe的initialDelaySeconds来解决。</p>
<p>启动探针启动时执行，如果定义了启动探针，那么在启动探针探测成功之前，其他探针都不会进行探测。如果启动探针探测失败，kubelet会杀死容器，容器将按照<code>Restart Policy</code>进行重启。如果没有定义startupProbe，那么默认为<code>Success</code></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>省略的Pod的yaml文件中其他配置，仅保留了spec.containers.livenessProbe相关</p>
<h3 id="exec探针"><a href="#exec探针" class="headerlink" title="exec探针"></a>exec探针</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot; touch /tmp/healthy;sleep 60; rm -rf /tmp/healthy; sleep 600&quot;</span>]</span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;test&quot;</span>,<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;/tmp/healthy&quot;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="tcpSocket探针"><a href="#tcpSocket探针" class="headerlink" title="tcpSocket探针"></a>tcpSocket探针</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="httpGet探针"><a href="#httpGet探针" class="headerlink" title="httpGet探针"></a>httpGet探针</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/ping</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="探针的创建与工作，源码解析"><a href="#探针的创建与工作，源码解析" class="headerlink" title="探针的创建与工作，源码解析"></a>探针的创建与工作，源码解析</h2><p>相关代码基于kubernetes1.20.4</p>
<h3 id="创建probeManager对象，管理探针和探针检测结果"><a href="#创建probeManager对象，管理探针和探针检测结果" class="headerlink" title="创建probeManager对象，管理探针和探针检测结果"></a>创建probeManager对象，管理探针和探针检测结果</h3><ol>
<li>在启动kubelet时，kubelet会创建probeManager对象 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">klet.probeManager = prober.NewManager(</span><br><span class="line">    klet.statusManager,</span><br><span class="line">    klet.livenessManager,</span><br><span class="line">    klet.startupManager,</span><br><span class="line">    klet.runner,</span><br><span class="line">    kubeDeps.Recorder)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewManager创建了管理pod的各种探针的Manager</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  statusManager status.Manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  livenessManager results.Manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  startupManager results.Manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  runner kubecontainer.CommandRunner,</span></span></span><br><span class="line"><span class="params"><span class="function">  recorder record.EventRecorder)</span> <span class="title">Manager</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  prober := newProber(runner, recorder)</span><br><span class="line">  readinessManager := results.NewManager()</span><br><span class="line">  <span class="keyword">return</span> &amp;manager&#123;</span><br><span class="line">    statusManager:    statusManager,</span><br><span class="line">    prober:           prober,</span><br><span class="line">    readinessManager: readinessManager,</span><br><span class="line">    livenessManager:  livenessManager,</span><br><span class="line">    startupManager:   startupManager,</span><br><span class="line">    workers:          <span class="built_in">make</span>(<span class="keyword">map</span>[probeKey]*worker),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 results.Manager是一个管理器，里面用hashmap存放着容器探针的检测结果。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// guards the cache</span></span><br><span class="line">  sync.RWMutex</span><br><span class="line">  <span class="comment">// map of container ID -&gt; probe Result</span></span><br><span class="line">  cache <span class="keyword">map</span>[kubecontainer.ContainerID]Result</span><br><span class="line">  <span class="comment">// channel of updates</span></span><br><span class="line">  updates <span class="keyword">chan</span> Update</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="根据Container的Probe相关属性创建Worker"><a href="#根据Container的Probe相关属性创建Worker" class="headerlink" title="根据Container的Probe相关属性创建Worker"></a>根据Container的Probe相关属性创建Worker</h3><ol start="2">
<li><p>创建Pod的时候，遍历Pod中的容器，判断容器是否添加了StartupProbe、ReadinessProbe、LivenessProbe，如果添加了，就会为这个探针创建一个Worker对象。这个worker在一个goroutine中进行检测工作。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/prober_manager.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">AddPod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 读写锁</span></span><br><span class="line">  m.workerLock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.workerLock.Unlock()</span><br><span class="line"></span><br><span class="line">  key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line">  <span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">    key.containerName = c.Name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.StartupProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">      key.probeType = startup</span><br><span class="line">      <span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;Startup probe already exists! %v - %v&quot;</span>,</span><br><span class="line">          format.Pod(pod), c.Name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      w := newWorker(m, startup, pod, c)</span><br><span class="line">      m.workers[key] = w</span><br><span class="line">      <span class="keyword">go</span> w.run()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.ReadinessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">      key.probeType = readiness</span><br><span class="line">      <span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;Readiness probe already exists! %v - %v&quot;</span>,</span><br><span class="line">          format.Pod(pod), c.Name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      w := newWorker(m, readiness, pod, c)</span><br><span class="line">      m.workers[key] = w</span><br><span class="line">      <span class="keyword">go</span> w.run()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.LivenessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">      key.probeType = liveness</span><br><span class="line">      <span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">        klog.Errorf(<span class="string">&quot;Liveness probe already exists! %v - %v&quot;</span>,</span><br><span class="line">          format.Pod(pod), c.Name)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      w := newWorker(m, liveness, pod, c)</span><br><span class="line">      m.workers[key] = w</span><br><span class="line">      <span class="keyword">go</span> w.run()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="每个探针的worker是什么"><a href="#每个探针的worker是什么" class="headerlink" title="每个探针的worker是什么"></a>每个探针的worker是什么</h3></li>
<li><p>newWorker操作会创建一个probe worker，worker定义。初始化worker时，会为其赋值pod、container的相关信息。并根据探针类型，初始化其默认状态：<code>readinessProbe</code>的默认值是<code>Failure</code>，<code>livenessProbe</code>的默认值是<code>Success</code>，<code>startupProbe</code>的初始值是<code>UNKNOWN</code></p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/worker.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWorker</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  m *manager,</span></span></span><br><span class="line"><span class="params"><span class="function">  probeType probeType,</span></span></span><br><span class="line"><span class="params"><span class="function">  pod *v1.Pod,</span></span></span><br><span class="line"><span class="params"><span class="function">  container v1.Container)</span> *<span class="title">worker</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  w := &amp;worker&#123;</span><br><span class="line">    stopCh:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>), <span class="comment">// Buffer so stop() can be non-blocking.</span></span><br><span class="line">    pod:          pod,</span><br><span class="line">    container:    container,</span><br><span class="line">    probeType:    probeType,</span><br><span class="line">    probeManager: m,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> probeType &#123;</span><br><span class="line">  <span class="keyword">case</span> readiness:</span><br><span class="line">    w.spec = container.ReadinessProbe</span><br><span class="line">    w.resultsManager = m.readinessManager</span><br><span class="line">    w.initialValue = results.Failure</span><br><span class="line">  <span class="keyword">case</span> liveness:</span><br><span class="line">    w.spec = container.LivenessProbe</span><br><span class="line">    w.resultsManager = m.livenessManager</span><br><span class="line">    w.initialValue = results.Success</span><br><span class="line">  <span class="keyword">case</span> startup:</span><br><span class="line">    w.spec = container.StartupProbe</span><br><span class="line">    w.resultsManager = m.startupManager</span><br><span class="line">    w.initialValue = results.Unknown</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  basicMetricLabels := metrics.Labels&#123;</span><br><span class="line">    <span class="string">&quot;probe_type&quot;</span>: w.probeType.String(),</span><br><span class="line">    <span class="string">&quot;container&quot;</span>:  w.container.Name,</span><br><span class="line">    <span class="string">&quot;pod&quot;</span>:        w.pod.Name,</span><br><span class="line">    <span class="string">&quot;namespace&quot;</span>:  w.pod.Namespace,</span><br><span class="line">    <span class="string">&quot;pod_uid&quot;</span>:    <span class="keyword">string</span>(w.pod.UID),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prometheus收集时需要的数据格式</span></span><br><span class="line">  w.proberResultsSuccessfulMetricLabels = deepCopyPrometheusLabels(basicMetricLabels)</span><br><span class="line">  w.proberResultsSuccessfulMetricLabels[<span class="string">&quot;result&quot;</span>] = probeResultSuccessful</span><br><span class="line"></span><br><span class="line">  w.proberResultsFailedMetricLabels = deepCopyPrometheusLabels(basicMetricLabels)</span><br><span class="line">  w.proberResultsFailedMetricLabels[<span class="string">&quot;result&quot;</span>] = probeResultFailed</span><br><span class="line"></span><br><span class="line">  w.proberResultsUnknownMetricLabels = deepCopyPrometheusLabels(basicMetricLabels)</span><br><span class="line">  w.proberResultsUnknownMetricLabels[<span class="string">&quot;result&quot;</span>] = probeResultUnknown</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="comment">// 用于停止probe，newWorker()时默认为make(chan struct&#123;&#125;,1)</span></span><br><span class="line">  stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 只读</span></span><br><span class="line">  pod *v1.Pod</span><br><span class="line">  <span class="comment">// 只读</span></span><br><span class="line">  container v1.Container</span><br><span class="line"></span><br><span class="line">  spec *v1.Probe</span><br><span class="line">  probeType probeType</span><br><span class="line">  initialValue results.Result</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于存放探测结果</span></span><br><span class="line">  resultsManager results.Manager</span><br><span class="line">  probeManager   *manager</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当前worker最近一次探测的容器id</span></span><br><span class="line">  containerID kubecontainer.ContainerID</span><br><span class="line">  <span class="comment">// 最近一次探测结果</span></span><br><span class="line">  lastResult results.Result</span><br><span class="line">  <span class="comment">// 探测结果相同的次数</span></span><br><span class="line">  resultRun <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否跳过探测</span></span><br><span class="line">  onHold <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 探测结果标签</span></span><br><span class="line">  proberResultsSuccessfulMetricLabels metrics.Labels</span><br><span class="line">  proberResultsFailedMetricLabels     metrics.Labels</span><br><span class="line">  proberResultsUnknownMetricLabels    metrics.Labels</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="worker的具体工作内容"><a href="#worker的具体工作内容" class="headerlink" title="worker的具体工作内容"></a>worker的具体工作内容</h3><ol start="4">
<li>worker.run()中，根据Container定义的探针，获取周期，然后根据时间间隔，循环执行doProbe() <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  probeTickerPeriod := time.Duration(w.spec.PeriodSeconds) * time.Second</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If kubelet restarted the probes could be started in rapid succession.</span></span><br><span class="line">  <span class="comment">// Let the worker wait for a random portion of tickerPeriod before probing.</span></span><br><span class="line">  time.Sleep(time.Duration(rand.Float64() * <span class="keyword">float64</span>(probeTickerPeriod)))</span><br><span class="line"></span><br><span class="line">  probeTicker := time.NewTicker(probeTickerPeriod)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Clean up.</span></span><br><span class="line">    probeTicker.Stop()</span><br><span class="line">    <span class="keyword">if</span> !w.containerID.IsEmpty() &#123;</span><br><span class="line">      w.resultsManager.Remove(w.containerID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.probeManager.removeWorker(w.pod.UID, w.container.Name, w.probeType)</span><br><span class="line">    ProberResults.Delete(w.proberResultsSuccessfulMetricLabels)</span><br><span class="line">    ProberResults.Delete(w.proberResultsFailedMetricLabels)</span><br><span class="line">    ProberResults.Delete(w.proberResultsUnknownMetricLabels)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">probeLoop:</span><br><span class="line">  <span class="keyword">for</span> w.doProbe() &#123;</span><br><span class="line">    <span class="comment">// Wait for next probe tick.</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-w.stopCh:</span><br><span class="line">      <span class="keyword">break</span> probeLoop</span><br><span class="line">    <span class="keyword">case</span> &lt;-probeTicker.C:</span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h3><ol start="5">
<li><p>doProbe()方法，对container进行一次探测，然后向Manager记录探测结果，并根据执行结果判断是否还需要继续探测。即从kubelet的Manager来获取Pod的状态。<br>kubelet的Manager通过ClientSet获取Pod对象，用来保证Pod的最新的status，它会把Pod的status信息同步更新到apiserver。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">doProbe</span><span class="params">()</span> <span class="params">(keepGoing <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">recover</span>() &#125;() <span class="comment">// 发生panic，捕获后不处理，直接吞掉</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">defer</span> runtime.HandleCrash(<span class="function"><span class="keyword">func</span><span class="params">(_ <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123; keepGoing = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从kubelet的Manager获取Pod的status</span></span><br><span class="line">  status, ok := w.probeManager.statusManager.GetPodStatus(w.pod.UID)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// Pod还没有被创建，或者已经被删除</span></span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;No status for pod: %v&quot;</span>, format.Pod(w.pod))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pod如果已经终止了，就不再需要Worker了</span></span><br><span class="line">  <span class="keyword">if</span> status.Phase == v1.PodFailed || status.Phase == v1.PodSucceeded &#123;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Pod %v %v, exiting probe worker&quot;</span>,</span><br><span class="line">      format.Pod(w.pod), status.Phase)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从hashmap里获取Pod对象中的Container状态，</span></span><br><span class="line">  c, ok := podutil.GetContainerStatus(status.ContainerStatuses, w.container.Name)</span><br><span class="line">  <span class="keyword">if</span> !ok || <span class="built_in">len</span>(c.ContainerID) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Either the container has not been created yet, or it was deleted.</span></span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Probe target container not found: %v - %v&quot;</span>,</span><br><span class="line">      format.Pod(w.pod), w.container.Name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// Wait for more information.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// container发生变化时，将新的container存放到resultsManager里</span></span><br><span class="line">  <span class="keyword">if</span> w.containerID.String() != c.ContainerID &#123;</span><br><span class="line">    <span class="keyword">if</span> !w.containerID.IsEmpty() &#123;</span><br><span class="line">      w.resultsManager.Remove(w.containerID)</span><br><span class="line">    &#125;</span><br><span class="line">    w.containerID = kubecontainer.ParseContainerID(c.ContainerID)</span><br><span class="line">    w.resultsManager.Set(w.containerID, w.initialValue, w.pod)</span><br><span class="line">    <span class="comment">// We&#x27;ve got a new container; resume probing.</span></span><br><span class="line">    w.onHold = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> w.onHold &#123;</span><br><span class="line">    <span class="comment">// Worker is on hold until there is a new container.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取不到container状态是，将结果设置为Failure</span></span><br><span class="line">  <span class="keyword">if</span> c.State.Running == <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Non-running container probed: %v - %v&quot;</span>,</span><br><span class="line">      format.Pod(w.pod), w.container.Name)</span><br><span class="line">    <span class="keyword">if</span> !w.containerID.IsEmpty() &#123;</span><br><span class="line">      w.resultsManager.Set(w.containerID, results.Failure, w.pod)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Abort if the container will not be restarted.</span></span><br><span class="line">    <span class="keyword">return</span> c.State.Terminated == <span class="literal">nil</span> ||</span><br><span class="line">      w.pod.Spec.RestartPolicy != v1.RestartPolicyNever</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动时间小于设置探针的延迟探测时间，则Worker继续下一次探测</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">int32</span>(time.Since(c.State.Running.StartedAt.Time).Seconds()) &lt; w.spec.InitialDelaySeconds &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果容器的没有启动起来，那么只有startupProbe才会进行探测，其他的probe worker，就一直在循环等待。</span></span><br><span class="line">  <span class="comment">// 如果容器已经started，那么startupProbe，就直接返回true,不用再执行probe()探测了</span></span><br><span class="line">  <span class="keyword">if</span> c.Started != <span class="literal">nil</span> &amp;&amp; *c.Started &#123;</span><br><span class="line">    <span class="keyword">if</span> w.probeType == startup &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> w.probeType != startup &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 探测容器，获取容器状态</span></span><br><span class="line">  result, err := w.probeManager.prober.probe(w.probeType, w.pod, status, w.container, w.containerID)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Prober error, throw away the result.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Metric状态收集</span></span><br><span class="line">  <span class="keyword">switch</span> result &#123;</span><br><span class="line">  <span class="keyword">case</span> results.Success:</span><br><span class="line">    ProberResults.With(w.proberResultsSuccessfulMetricLabels).Inc()</span><br><span class="line">  <span class="keyword">case</span> results.Failure:</span><br><span class="line">    ProberResults.With(w.proberResultsFailedMetricLabels).Inc()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    ProberResults.With(w.proberResultsUnknownMetricLabels).Inc()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> w.lastResult == result &#123;</span><br><span class="line">    w.resultRun++</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    w.lastResult = result</span><br><span class="line">    w.resultRun = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == results.Failure &amp;&amp; w.resultRun &lt; <span class="keyword">int</span>(w.spec.FailureThreshold)) ||</span><br><span class="line">    (result == results.Success &amp;&amp; w.resultRun &lt; <span class="keyword">int</span>(w.spec.SuccessThreshold)) &#123;</span><br><span class="line">    <span class="comment">// Success or failure is below threshold - leave the probe state unchanged.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录探测结果</span></span><br><span class="line">  w.resultsManager.Set(w.containerID, result, w.pod)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w.probeType == liveness || w.probeType == startup) &amp;&amp; result == results.Failure &#123;</span><br><span class="line">    <span class="comment">// 容器存活检查失败或者启动检查失败时，需要重新启动容器。停止探测，直到获取了新的containerId。</span></span><br><span class="line">    w.onHold = <span class="literal">true</span></span><br><span class="line">    w.resultRun = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="根据探针类型进行相应操作处理"><a href="#根据探针类型进行相应操作处理" class="headerlink" title="根据探针类型进行相应操作处理"></a>根据探针类型进行相应操作处理</h3><ol start="6">
<li>w.probeManager.prober.probe(w.probeType, w.pod, status, w.container, w.containerID)，会调用到runProbe()，根据probeType，进行具体处理。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">runProbe</span><span class="params">(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  timeout := time.Duration(p.TimeoutSeconds) * time.Second</span><br><span class="line">  <span class="keyword">if</span> p.Exec != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Exec-Probe Pod: %v, Container: %v, Command: %v&quot;</span>, pod.Name, container.Name, p.Exec.Command)</span><br><span class="line">    command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)</span><br><span class="line">    <span class="keyword">return</span> pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> p.HTTPGet != <span class="literal">nil</span> &#123;</span><br><span class="line">    scheme := strings.ToLower(<span class="keyword">string</span>(p.HTTPGet.Scheme))</span><br><span class="line">    host := p.HTTPGet.Host</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      host = status.PodIP</span><br><span class="line">    &#125;</span><br><span class="line">    port, err := extractPort(p.HTTPGet.Port, container)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> probe.Unknown, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    path := p.HTTPGet.Path</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;HTTP-Probe Host: %v://%v, Port: %v, Path: %v&quot;</span>, scheme, host, port, path)</span><br><span class="line">    url := formatURL(scheme, host, port, path)</span><br><span class="line">    headers := buildHeader(p.HTTPGet.HTTPHeaders)</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;HTTP-Probe Headers: %v&quot;</span>, headers)</span><br><span class="line">    <span class="keyword">switch</span> probeType &#123;</span><br><span class="line">    <span class="keyword">case</span> liveness:</span><br><span class="line">      <span class="keyword">return</span> pb.livenessHTTP.Probe(url, headers, timeout)</span><br><span class="line">    <span class="keyword">case</span> startup:</span><br><span class="line">      <span class="keyword">return</span> pb.startupHTTP.Probe(url, headers, timeout)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> pb.readinessHTTP.Probe(url, headers, timeout)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> p.TCPSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">    port, err := extractPort(p.TCPSocket.Port, container)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> probe.Unknown, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    host := p.TCPSocket.Host</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      host = status.PodIP</span><br><span class="line">    &#125;</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;TCP-Probe Host: %v, Port: %v, Timeout: %v&quot;</span>, host, port, timeout)</span><br><span class="line">    <span class="keyword">return</span> pb.tcp.Probe(host, port, timeout)</span><br><span class="line">  &#125;</span><br><span class="line">  klog.Warningf(<span class="string">&quot;Failed to find probe builder for container: %v&quot;</span>, container)</span><br><span class="line">  <span class="keyword">return</span> probe.Unknown, <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;missing probe handler for %s:%s&quot;</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="具体操作执行方法"><a href="#具体操作执行方法" class="headerlink" title="具体操作执行方法"></a>具体操作执行方法</h3><ol start="7">
<li>根据probeType，会执行对应的execProber.Probe()、httpProber.Probe()、tcpProber.Probe()。相应方法定义在<code>pkg/probe</code></li>
</ol>
<ul>
<li>如果是exec，那么就会解析exec.command，然后<code>k8s.io/utils/exec</code>的ioutil执行命令，判断exited的值是否为0，如果为0则返回<code>probe.Success</code>，否则返回<code>probe.Failure</code>，如果执行命令发生超时，则返回<code>probe.Unknown</code> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pr execProber)</span> <span class="title">Probe</span><span class="params">(e exec.Cmd)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  writer := ioutils.LimitWriter(&amp;dataBuffer, maxReadLength)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果是HTTPGet，那么会发送一个Http的get请求，如果发生error，就返回<code>probe.Failure</code>。通过http状态码进行健康检测，如果StatusCode为<code>2xx</code>，就返回<code>probe.Success</code>，如果为<code>3xx</code>就返回<code>probe.Warning</code>。<code>probe.Warning</code>的意思是，逻辑上是成功了，但是会附带一些额外的调试信息。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoHTTPProbe</span><span class="params">(url *url.URL, headers http.Header, client GetHTTPInterface)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url.String(), <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> probe.Failure, err.Error(), <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对Header的一系列处理</span></span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过GetHTTPInterface发送Request</span></span><br><span class="line">  res, err := client.Do(req)</span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  b, err := utilio.ReadAtMost(res.Body, maxRespBodyLength)</span><br><span class="line">  <span class="comment">// 获取http状态码，20</span></span><br><span class="line">  body := <span class="keyword">string</span>(b)</span><br><span class="line">  <span class="keyword">if</span> res.StatusCode &gt;= http.StatusOK &amp;&amp; res.StatusCode &lt; http.StatusBadRequest &#123;</span><br><span class="line">    <span class="keyword">if</span> res.StatusCode &gt;= http.StatusMultipleChoices &#123; <span class="comment">// Redirect</span></span><br><span class="line">      klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Probe terminated redirects for %s, Response: %v&quot;</span>, url.String(), *res)</span><br><span class="line">      <span class="keyword">return</span> probe.Warning, body, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Probe succeeded for %s, Response: %v&quot;</span>, url.String(), *res)</span><br><span class="line">    <span class="keyword">return</span> probe.Success, body, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">&quot;HTTP probe failed with statuscode: %d&quot;</span>, res.StatusCode), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>如果是TCPSocket，则通过<code>主机+端口号</code>，检测是否可以建立TCP Socket，如果可以就返回Success，如果不可以，就返回Failure。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pr tcpProber)</span> <span class="title">Probe</span><span class="params">(host <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 拼接主机+端口号</span></span><br><span class="line">  <span class="keyword">return</span> DoTCPProbe(net.JoinHostPort(host, strconv.Itoa(port)), timeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoTCPProbe检查到该地址的TCP Socket是否可以打开</span></span><br><span class="line"><span class="comment">// TCP Socket可以打开返回Success，反之返回Failure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoTCPProbe</span><span class="params">(addr <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  conn, err := net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, addr, timeout)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> probe.Failure, err.Error(), <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  err = conn.Close()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">&quot;Unexpected error closing TCP probe socket: %v (%#v)&quot;</span>, err, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> probe.Success, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Pod</tag>
      </tags>
  </entry>
</search>
